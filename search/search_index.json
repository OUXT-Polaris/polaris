{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"What is POLARIS # \" P olicy and O bject map description L anguage for A utomated R obot I ntelligence with S emantic behavior\" Purpose # Describe robotic behavior much more easilly. # Describing robotic behacior is very very hard task. We usually use algorithums such as behavior tree, PDDL (Planning Domain Definition Language) model etc... We try this problem by developing Domain Specific Language. Example of PDDL in robot navigation. (:action navigate :parameters (?r \u2013 rover ?x ?y - waypoint) :precondition (and (available ?r) (at ?r ?x) (visible ?x ?y) (>= (energy ?r) 8)) :effect (and (decrease (energy ?r) 8) (not (at ?r ?x )) (at ?r ?y))) Example of behavior tree in robot navigation. Describe semantic behavior clearly. # By using POLARIS language, we can describe robotic behacior cleary such as \"Go to in front of the white bouy and stop.\", \"Turn the red handle.\"","title":"Home"},{"location":"#what-is-polaris","text":"\" P olicy and O bject map description L anguage for A utomated R obot I ntelligence with S emantic behavior\"","title":"What is POLARIS"},{"location":"#purpose","text":"","title":"Purpose"},{"location":"#describe-robotic-behavior-much-more-easilly","text":"Describing robotic behacior is very very hard task. We usually use algorithums such as behavior tree, PDDL (Planning Domain Definition Language) model etc... We try this problem by developing Domain Specific Language. Example of PDDL in robot navigation. (:action navigate :parameters (?r \u2013 rover ?x ?y - waypoint) :precondition (and (available ?r) (at ?r ?x) (visible ?x ?y) (>= (energy ?r) 8)) :effect (and (decrease (energy ?r) 8) (not (at ?r ?x )) (at ?r ?y))) Example of behavior tree in robot navigation.","title":"Describe robotic behavior much more easilly."},{"location":"#describe-semantic-behavior-clearly","text":"By using POLARIS language, we can describe robotic behacior cleary such as \"Go to in front of the white bouy and stop.\", \"Turn the red handle.\"","title":"Describe semantic behavior clearly."},{"location":"doxygen/markdown/Classes/","text":"Classes # namespace polaris class EvaluationError class Parser namespace built_in_functions class Functions namespace types class Entity class TypeBase Updated on 26 December 2020 at 00:59:10 UTC","title":"Classes"},{"location":"doxygen/markdown/Classes/#classes","text":"namespace polaris class EvaluationError class Parser namespace built_in_functions class Functions namespace types class Entity class TypeBase Updated on 26 December 2020 at 00:59:10 UTC","title":"Classes"},{"location":"doxygen/markdown/Classes/classpolaris_1_1EvaluationError/","text":"polaris::EvaluationError # Inherits from runtime_error Public Functions # Name EvaluationError (std::shared_ptr< peg::Ast > ast, std::string description, const char * file, int line) Public Attributes # Name const std::string description const std::string ast_string Public Functions Documentation # function EvaluationError # inline EvaluationError ( std :: shared_ptr < peg :: Ast > ast , std :: string description , const char * file , int line ) Public Attributes Documentation # variable description # const std :: string description ; variable ast_string # const std :: string ast_string ; Updated on 26 December 2020 at 00:59:10 UTC","title":"polaris::EvaluationError"},{"location":"doxygen/markdown/Classes/classpolaris_1_1EvaluationError/#polarisevaluationerror","text":"Inherits from runtime_error","title":"polaris::EvaluationError"},{"location":"doxygen/markdown/Classes/classpolaris_1_1EvaluationError/#public-functions","text":"Name EvaluationError (std::shared_ptr< peg::Ast > ast, std::string description, const char * file, int line)","title":"Public Functions"},{"location":"doxygen/markdown/Classes/classpolaris_1_1EvaluationError/#public-attributes","text":"Name const std::string description const std::string ast_string","title":"Public Attributes"},{"location":"doxygen/markdown/Classes/classpolaris_1_1EvaluationError/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"doxygen/markdown/Classes/classpolaris_1_1EvaluationError/#function-evaluationerror","text":"inline EvaluationError ( std :: shared_ptr < peg :: Ast > ast , std :: string description , const char * file , int line )","title":"function EvaluationError"},{"location":"doxygen/markdown/Classes/classpolaris_1_1EvaluationError/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"doxygen/markdown/Classes/classpolaris_1_1EvaluationError/#variable-description","text":"const std :: string description ;","title":"variable description"},{"location":"doxygen/markdown/Classes/classpolaris_1_1EvaluationError/#variable-ast_string","text":"const std :: string ast_string ; Updated on 26 December 2020 at 00:59:10 UTC","title":"variable ast_string"},{"location":"doxygen/markdown/Classes/classpolaris_1_1Parser/","text":"polaris::Parser # Public Functions # Name template \\<typename T > const boost::optional< T > getValue (std::string name) const bool evaluate (std::string line) Parser (bool verbose =true) Public Functions Documentation # function getValue # template < typename T > inline const boost :: optional < T > getValue ( std :: string name ) const function evaluate # bool evaluate ( std :: string line ) function Parser # explicit Parser ( bool verbose = true ) Updated on 26 December 2020 at 00:59:10 UTC","title":"polaris::Parser"},{"location":"doxygen/markdown/Classes/classpolaris_1_1Parser/#polarisparser","text":"","title":"polaris::Parser"},{"location":"doxygen/markdown/Classes/classpolaris_1_1Parser/#public-functions","text":"Name template \\<typename T > const boost::optional< T > getValue (std::string name) const bool evaluate (std::string line) Parser (bool verbose =true)","title":"Public Functions"},{"location":"doxygen/markdown/Classes/classpolaris_1_1Parser/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"doxygen/markdown/Classes/classpolaris_1_1Parser/#function-getvalue","text":"template < typename T > inline const boost :: optional < T > getValue ( std :: string name ) const","title":"function getValue"},{"location":"doxygen/markdown/Classes/classpolaris_1_1Parser/#function-evaluate","text":"bool evaluate ( std :: string line )","title":"function evaluate"},{"location":"doxygen/markdown/Classes/classpolaris_1_1Parser/#function-parser","text":"explicit Parser ( bool verbose = true ) Updated on 26 December 2020 at 00:59:10 UTC","title":"function Parser"},{"location":"doxygen/markdown/Classes/classpolaris_1_1built__in__functions_1_1Functions/","text":"polaris::built_in_functions::Functions # Public Functions # Name void setVariables (std::unordered_map< std::string, boost::any > variables) boost::any evaluate (std::string function, std::shared_ptr< peg::Ast > ast) Functions () Public Functions Documentation # function setVariables # inline void setVariables ( std :: unordered_map < std :: string , boost :: any > variables ) function evaluate # inline boost :: any evaluate ( std :: string function , std :: shared_ptr < peg :: Ast > ast ) function Functions # inline Functions () Updated on 26 December 2020 at 00:59:10 UTC","title":"polaris::built_in_functions::Functions"},{"location":"doxygen/markdown/Classes/classpolaris_1_1built__in__functions_1_1Functions/#polarisbuilt_in_functionsfunctions","text":"","title":"polaris::built_in_functions::Functions"},{"location":"doxygen/markdown/Classes/classpolaris_1_1built__in__functions_1_1Functions/#public-functions","text":"Name void setVariables (std::unordered_map< std::string, boost::any > variables) boost::any evaluate (std::string function, std::shared_ptr< peg::Ast > ast) Functions ()","title":"Public Functions"},{"location":"doxygen/markdown/Classes/classpolaris_1_1built__in__functions_1_1Functions/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"doxygen/markdown/Classes/classpolaris_1_1built__in__functions_1_1Functions/#function-setvariables","text":"inline void setVariables ( std :: unordered_map < std :: string , boost :: any > variables )","title":"function setVariables"},{"location":"doxygen/markdown/Classes/classpolaris_1_1built__in__functions_1_1Functions/#function-evaluate","text":"inline boost :: any evaluate ( std :: string function , std :: shared_ptr < peg :: Ast > ast )","title":"function evaluate"},{"location":"doxygen/markdown/Classes/classpolaris_1_1built__in__functions_1_1Functions/#function-functions","text":"inline Functions () Updated on 26 December 2020 at 00:59:10 UTC","title":"function Functions"},{"location":"doxygen/markdown/Classes/classpolaris_1_1types_1_1Entity/","text":"polaris::types::Entity # Public Functions # Name Entity () Entity (geometry_msgs::msg::Pose pose, std::vector< std::string > type, std::vector< geometry_msgs::msg::Point > polygon) Entity (geometry_msgs::msg::Pose pose, std::string type, std::vector< geometry_msgs::msg::Point > polygon) Public Attributes # Name std::vector< std::string > type geometry_msgs::msg::Pose pose std::vector< geometry_msgs::msg::Point > polygon Public Functions Documentation # function Entity # inline Entity () function Entity # inline explicit Entity ( geometry_msgs :: msg :: Pose pose , std :: vector < std :: string > type , std :: vector < geometry_msgs :: msg :: Point > polygon ) function Entity # inline explicit Entity ( geometry_msgs :: msg :: Pose pose , std :: string type , std :: vector < geometry_msgs :: msg :: Point > polygon ) Public Attributes Documentation # variable type # std :: vector < std :: string > type ; variable pose # geometry_msgs :: msg :: Pose pose ; variable polygon # std :: vector < geometry_msgs :: msg :: Point > polygon ; Updated on 26 December 2020 at 00:59:10 UTC","title":"polaris::types::Entity"},{"location":"doxygen/markdown/Classes/classpolaris_1_1types_1_1Entity/#polaristypesentity","text":"","title":"polaris::types::Entity"},{"location":"doxygen/markdown/Classes/classpolaris_1_1types_1_1Entity/#public-functions","text":"Name Entity () Entity (geometry_msgs::msg::Pose pose, std::vector< std::string > type, std::vector< geometry_msgs::msg::Point > polygon) Entity (geometry_msgs::msg::Pose pose, std::string type, std::vector< geometry_msgs::msg::Point > polygon)","title":"Public Functions"},{"location":"doxygen/markdown/Classes/classpolaris_1_1types_1_1Entity/#public-attributes","text":"Name std::vector< std::string > type geometry_msgs::msg::Pose pose std::vector< geometry_msgs::msg::Point > polygon","title":"Public Attributes"},{"location":"doxygen/markdown/Classes/classpolaris_1_1types_1_1Entity/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"doxygen/markdown/Classes/classpolaris_1_1types_1_1Entity/#function-entity","text":"inline Entity ()","title":"function Entity"},{"location":"doxygen/markdown/Classes/classpolaris_1_1types_1_1Entity/#function-entity_1","text":"inline explicit Entity ( geometry_msgs :: msg :: Pose pose , std :: vector < std :: string > type , std :: vector < geometry_msgs :: msg :: Point > polygon )","title":"function Entity"},{"location":"doxygen/markdown/Classes/classpolaris_1_1types_1_1Entity/#function-entity_2","text":"inline explicit Entity ( geometry_msgs :: msg :: Pose pose , std :: string type , std :: vector < geometry_msgs :: msg :: Point > polygon )","title":"function Entity"},{"location":"doxygen/markdown/Classes/classpolaris_1_1types_1_1Entity/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"doxygen/markdown/Classes/classpolaris_1_1types_1_1Entity/#variable-type","text":"std :: vector < std :: string > type ;","title":"variable type"},{"location":"doxygen/markdown/Classes/classpolaris_1_1types_1_1Entity/#variable-pose","text":"geometry_msgs :: msg :: Pose pose ;","title":"variable pose"},{"location":"doxygen/markdown/Classes/classpolaris_1_1types_1_1Entity/#variable-polygon","text":"std :: vector < geometry_msgs :: msg :: Point > polygon ; Updated on 26 December 2020 at 00:59:10 UTC","title":"variable polygon"},{"location":"doxygen/markdown/Classes/classpolaris_1_1types_1_1TypeBase/","text":"polaris::types::TypeBase # More... Public Functions # Name void setValue (const T & v) bool matchValueType (const std::type_info & type) const T getValue () const TypeBase () TypeBase (const T & v) Detailed Description # template < typename T > class polaris :: types :: TypeBase ; Public Functions Documentation # function setValue # inline void setValue ( const T & v ) function matchValueType # inline bool matchValueType ( const std :: type_info & type ) const function getValue # inline T getValue () const function TypeBase # inline TypeBase () function TypeBase # inline explicit TypeBase ( const T & v ) Updated on 26 December 2020 at 00:59:10 UTC","title":"polaris::types::TypeBase"},{"location":"doxygen/markdown/Classes/classpolaris_1_1types_1_1TypeBase/#polaristypestypebase","text":"More...","title":"polaris::types::TypeBase"},{"location":"doxygen/markdown/Classes/classpolaris_1_1types_1_1TypeBase/#public-functions","text":"Name void setValue (const T & v) bool matchValueType (const std::type_info & type) const T getValue () const TypeBase () TypeBase (const T & v)","title":"Public Functions"},{"location":"doxygen/markdown/Classes/classpolaris_1_1types_1_1TypeBase/#detailed-description","text":"template < typename T > class polaris :: types :: TypeBase ;","title":"Detailed Description"},{"location":"doxygen/markdown/Classes/classpolaris_1_1types_1_1TypeBase/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"doxygen/markdown/Classes/classpolaris_1_1types_1_1TypeBase/#function-setvalue","text":"inline void setValue ( const T & v )","title":"function setValue"},{"location":"doxygen/markdown/Classes/classpolaris_1_1types_1_1TypeBase/#function-matchvaluetype","text":"inline bool matchValueType ( const std :: type_info & type ) const","title":"function matchValueType"},{"location":"doxygen/markdown/Classes/classpolaris_1_1types_1_1TypeBase/#function-getvalue","text":"inline T getValue () const","title":"function getValue"},{"location":"doxygen/markdown/Classes/classpolaris_1_1types_1_1TypeBase/#function-typebase","text":"inline TypeBase ()","title":"function TypeBase"},{"location":"doxygen/markdown/Classes/classpolaris_1_1types_1_1TypeBase/#function-typebase_1","text":"inline explicit TypeBase ( const T & v ) Updated on 26 December 2020 at 00:59:10 UTC","title":"function TypeBase"},{"location":"doxygen/markdown/Examples/","text":"Examples # Updated on 26 December 2020 at 00:59:10 UTC","title":"Examples"},{"location":"doxygen/markdown/Examples/#examples","text":"Updated on 26 December 2020 at 00:59:10 UTC","title":"Examples"},{"location":"doxygen/markdown/Files/","text":"Files # dir /home/runner/work/polaris/polaris/include dir /home/runner/work/polaris/polaris/include/polaris dir /home/runner/work/polaris/polaris/include/polaris/built_in_functions file /home/runner/work/polaris/polaris/include/polaris/built_in_functions/functions.hpp dir /home/runner/work/polaris/polaris/include/polaris/grammar file /home/runner/work/polaris/polaris/include/polaris/grammar/grammar.hpp dir /home/runner/work/polaris/polaris/include/polaris/parser file /home/runner/work/polaris/polaris/include/polaris/parser/parser.hpp dir /home/runner/work/polaris/polaris/include/polaris/types file /home/runner/work/polaris/polaris/include/polaris/types/entity.hpp file /home/runner/work/polaris/polaris/include/polaris/types/type_base.hpp file /home/runner/work/polaris/polaris/include/polaris/exception.hpp dir /home/runner/work/polaris/polaris/src dir /home/runner/work/polaris/polaris/src/built_in_functions file /home/runner/work/polaris/polaris/src/built_in_functions/functions.cpp dir /home/runner/work/polaris/polaris/src/example file /home/runner/work/polaris/polaris/src/example/example.cpp dir /home/runner/work/polaris/polaris/src/parser file /home/runner/work/polaris/polaris/src/parser/parser.cpp dir /home/runner/work/polaris/polaris/test file /home/runner/work/polaris/polaris/test/test_operator.cpp file /home/runner/work/polaris/polaris/test/test_types.cpp Updated on 26 December 2020 at 00:59:10 UTC","title":"Files"},{"location":"doxygen/markdown/Files/#files","text":"dir /home/runner/work/polaris/polaris/include dir /home/runner/work/polaris/polaris/include/polaris dir /home/runner/work/polaris/polaris/include/polaris/built_in_functions file /home/runner/work/polaris/polaris/include/polaris/built_in_functions/functions.hpp dir /home/runner/work/polaris/polaris/include/polaris/grammar file /home/runner/work/polaris/polaris/include/polaris/grammar/grammar.hpp dir /home/runner/work/polaris/polaris/include/polaris/parser file /home/runner/work/polaris/polaris/include/polaris/parser/parser.hpp dir /home/runner/work/polaris/polaris/include/polaris/types file /home/runner/work/polaris/polaris/include/polaris/types/entity.hpp file /home/runner/work/polaris/polaris/include/polaris/types/type_base.hpp file /home/runner/work/polaris/polaris/include/polaris/exception.hpp dir /home/runner/work/polaris/polaris/src dir /home/runner/work/polaris/polaris/src/built_in_functions file /home/runner/work/polaris/polaris/src/built_in_functions/functions.cpp dir /home/runner/work/polaris/polaris/src/example file /home/runner/work/polaris/polaris/src/example/example.cpp dir /home/runner/work/polaris/polaris/src/parser file /home/runner/work/polaris/polaris/src/parser/parser.cpp dir /home/runner/work/polaris/polaris/test file /home/runner/work/polaris/polaris/test/test_operator.cpp file /home/runner/work/polaris/polaris/test/test_types.cpp Updated on 26 December 2020 at 00:59:10 UTC","title":"Files"},{"location":"doxygen/markdown/Files/dir_13e138d54eb8818da29c3992edef070a/","text":"/home/runner/work/polaris/polaris/test # Files # Name /home/runner/work/polaris/polaris/test/test_types.cpp /home/runner/work/polaris/polaris/test/test_operator.cpp Updated on 26 December 2020 at 00:59:10 UTC","title":"/home/runner/work/polaris/polaris/test"},{"location":"doxygen/markdown/Files/dir_13e138d54eb8818da29c3992edef070a/#homerunnerworkpolarispolaristest","text":"","title":"/home/runner/work/polaris/polaris/test"},{"location":"doxygen/markdown/Files/dir_13e138d54eb8818da29c3992edef070a/#files","text":"Name /home/runner/work/polaris/polaris/test/test_types.cpp /home/runner/work/polaris/polaris/test/test_operator.cpp Updated on 26 December 2020 at 00:59:10 UTC","title":"Files"},{"location":"doxygen/markdown/Files/dir_14a023d13380e39d00b385a549760404/","text":"/home/runner/work/polaris/polaris/include/polaris/built_in_functions # Files # Name /home/runner/work/polaris/polaris/include/polaris/built_in_functions/functions.hpp Updated on 26 December 2020 at 00:59:10 UTC","title":"/home/runner/work/polaris/polaris/include/polaris/built_in_functions"},{"location":"doxygen/markdown/Files/dir_14a023d13380e39d00b385a549760404/#homerunnerworkpolarispolarisincludepolarisbuilt_in_functions","text":"","title":"/home/runner/work/polaris/polaris/include/polaris/built_in_functions"},{"location":"doxygen/markdown/Files/dir_14a023d13380e39d00b385a549760404/#files","text":"Name /home/runner/work/polaris/polaris/include/polaris/built_in_functions/functions.hpp Updated on 26 December 2020 at 00:59:10 UTC","title":"Files"},{"location":"doxygen/markdown/Files/dir_1ff95392bc4e65547c61a42698fda530/","text":"/home/runner/work/polaris/polaris/src/example # Files # Name /home/runner/work/polaris/polaris/src/example/example.cpp Updated on 26 December 2020 at 00:59:10 UTC","title":"/home/runner/work/polaris/polaris/src/example"},{"location":"doxygen/markdown/Files/dir_1ff95392bc4e65547c61a42698fda530/#homerunnerworkpolarispolarissrcexample","text":"","title":"/home/runner/work/polaris/polaris/src/example"},{"location":"doxygen/markdown/Files/dir_1ff95392bc4e65547c61a42698fda530/#files","text":"Name /home/runner/work/polaris/polaris/src/example/example.cpp Updated on 26 December 2020 at 00:59:10 UTC","title":"Files"},{"location":"doxygen/markdown/Files/dir_3c0cdd5ad5fc4808e48eb43a5dc064cf/","text":"/home/runner/work/polaris/polaris/src/built_in_functions # Files # Name /home/runner/work/polaris/polaris/src/built_in_functions/functions.cpp Updated on 26 December 2020 at 00:59:10 UTC","title":"/home/runner/work/polaris/polaris/src/built_in_functions"},{"location":"doxygen/markdown/Files/dir_3c0cdd5ad5fc4808e48eb43a5dc064cf/#homerunnerworkpolarispolarissrcbuilt_in_functions","text":"","title":"/home/runner/work/polaris/polaris/src/built_in_functions"},{"location":"doxygen/markdown/Files/dir_3c0cdd5ad5fc4808e48eb43a5dc064cf/#files","text":"Name /home/runner/work/polaris/polaris/src/built_in_functions/functions.cpp Updated on 26 December 2020 at 00:59:10 UTC","title":"Files"},{"location":"doxygen/markdown/Files/dir_68267d1309a1af8e8297ef4c3efbcdba/","text":"/home/runner/work/polaris/polaris/src # Directories # Name /home/runner/work/polaris/polaris/src/parser /home/runner/work/polaris/polaris/src/example /home/runner/work/polaris/polaris/src/built_in_functions Updated on 26 December 2020 at 00:59:10 UTC","title":"/home/runner/work/polaris/polaris/src"},{"location":"doxygen/markdown/Files/dir_68267d1309a1af8e8297ef4c3efbcdba/#homerunnerworkpolarispolarissrc","text":"","title":"/home/runner/work/polaris/polaris/src"},{"location":"doxygen/markdown/Files/dir_68267d1309a1af8e8297ef4c3efbcdba/#directories","text":"Name /home/runner/work/polaris/polaris/src/parser /home/runner/work/polaris/polaris/src/example /home/runner/work/polaris/polaris/src/built_in_functions Updated on 26 December 2020 at 00:59:10 UTC","title":"Directories"},{"location":"doxygen/markdown/Files/dir_6cd8491d143eb218b70983dbdb3c58bc/","text":"/home/runner/work/polaris/polaris/src/parser # Files # Name /home/runner/work/polaris/polaris/src/parser/parser.cpp Updated on 26 December 2020 at 00:59:10 UTC","title":"/home/runner/work/polaris/polaris/src/parser"},{"location":"doxygen/markdown/Files/dir_6cd8491d143eb218b70983dbdb3c58bc/#homerunnerworkpolarispolarissrcparser","text":"","title":"/home/runner/work/polaris/polaris/src/parser"},{"location":"doxygen/markdown/Files/dir_6cd8491d143eb218b70983dbdb3c58bc/#files","text":"Name /home/runner/work/polaris/polaris/src/parser/parser.cpp Updated on 26 December 2020 at 00:59:10 UTC","title":"Files"},{"location":"doxygen/markdown/Files/dir_9b0b78b757955f19ed4446bdf51f62cf/","text":"/home/runner/work/polaris/polaris/include/polaris/grammar # Files # Name /home/runner/work/polaris/polaris/include/polaris/grammar/grammar.hpp Updated on 26 December 2020 at 00:59:10 UTC","title":"/home/runner/work/polaris/polaris/include/polaris/grammar"},{"location":"doxygen/markdown/Files/dir_9b0b78b757955f19ed4446bdf51f62cf/#homerunnerworkpolarispolarisincludepolarisgrammar","text":"","title":"/home/runner/work/polaris/polaris/include/polaris/grammar"},{"location":"doxygen/markdown/Files/dir_9b0b78b757955f19ed4446bdf51f62cf/#files","text":"Name /home/runner/work/polaris/polaris/include/polaris/grammar/grammar.hpp Updated on 26 December 2020 at 00:59:10 UTC","title":"Files"},{"location":"doxygen/markdown/Files/dir_be60f1b74c6de77415c37973f0599dff/","text":"/home/runner/work/polaris/polaris/include/polaris # Directories # Name /home/runner/work/polaris/polaris/include/polaris/types /home/runner/work/polaris/polaris/include/polaris/parser /home/runner/work/polaris/polaris/include/polaris/grammar /home/runner/work/polaris/polaris/include/polaris/built_in_functions Files # Name /home/runner/work/polaris/polaris/include/polaris/exception.hpp Updated on 26 December 2020 at 00:59:10 UTC","title":"/home/runner/work/polaris/polaris/include/polaris"},{"location":"doxygen/markdown/Files/dir_be60f1b74c6de77415c37973f0599dff/#homerunnerworkpolarispolarisincludepolaris","text":"","title":"/home/runner/work/polaris/polaris/include/polaris"},{"location":"doxygen/markdown/Files/dir_be60f1b74c6de77415c37973f0599dff/#directories","text":"Name /home/runner/work/polaris/polaris/include/polaris/types /home/runner/work/polaris/polaris/include/polaris/parser /home/runner/work/polaris/polaris/include/polaris/grammar /home/runner/work/polaris/polaris/include/polaris/built_in_functions","title":"Directories"},{"location":"doxygen/markdown/Files/dir_be60f1b74c6de77415c37973f0599dff/#files","text":"Name /home/runner/work/polaris/polaris/include/polaris/exception.hpp Updated on 26 December 2020 at 00:59:10 UTC","title":"Files"},{"location":"doxygen/markdown/Files/dir_d44c64559bbebec7f509842c48db8b23/","text":"/home/runner/work/polaris/polaris/include # Directories # Name /home/runner/work/polaris/polaris/include/polaris Updated on 26 December 2020 at 00:59:10 UTC","title":"/home/runner/work/polaris/polaris/include"},{"location":"doxygen/markdown/Files/dir_d44c64559bbebec7f509842c48db8b23/#homerunnerworkpolarispolarisinclude","text":"","title":"/home/runner/work/polaris/polaris/include"},{"location":"doxygen/markdown/Files/dir_d44c64559bbebec7f509842c48db8b23/#directories","text":"Name /home/runner/work/polaris/polaris/include/polaris Updated on 26 December 2020 at 00:59:10 UTC","title":"Directories"},{"location":"doxygen/markdown/Files/dir_d7f1e173a14f13297d8b94749a7e1541/","text":"/home/runner/work/polaris/polaris/include/polaris/parser # Files # Name /home/runner/work/polaris/polaris/include/polaris/parser/parser.hpp Updated on 26 December 2020 at 00:59:10 UTC","title":"/home/runner/work/polaris/polaris/include/polaris/parser"},{"location":"doxygen/markdown/Files/dir_d7f1e173a14f13297d8b94749a7e1541/#homerunnerworkpolarispolarisincludepolarisparser","text":"","title":"/home/runner/work/polaris/polaris/include/polaris/parser"},{"location":"doxygen/markdown/Files/dir_d7f1e173a14f13297d8b94749a7e1541/#files","text":"Name /home/runner/work/polaris/polaris/include/polaris/parser/parser.hpp Updated on 26 December 2020 at 00:59:10 UTC","title":"Files"},{"location":"doxygen/markdown/Files/dir_f28305d1162a87b2dbdef00e7468a83d/","text":"/home/runner/work/polaris/polaris/include/polaris/types # Files # Name /home/runner/work/polaris/polaris/include/polaris/types/type_base.hpp /home/runner/work/polaris/polaris/include/polaris/types/entity.hpp Updated on 26 December 2020 at 00:59:10 UTC","title":"/home/runner/work/polaris/polaris/include/polaris/types"},{"location":"doxygen/markdown/Files/dir_f28305d1162a87b2dbdef00e7468a83d/#homerunnerworkpolarispolarisincludepolaristypes","text":"","title":"/home/runner/work/polaris/polaris/include/polaris/types"},{"location":"doxygen/markdown/Files/dir_f28305d1162a87b2dbdef00e7468a83d/#files","text":"Name /home/runner/work/polaris/polaris/include/polaris/types/type_base.hpp /home/runner/work/polaris/polaris/include/polaris/types/entity.hpp Updated on 26 December 2020 at 00:59:10 UTC","title":"Files"},{"location":"doxygen/markdown/Files/entity_8hpp/","text":"/home/runner/work/polaris/polaris/include/polaris/types/entity.hpp # Namespaces # Name polaris::types polaris Classes # Name class polaris::types::Entity Source code # // Copyright (c) 2020, OUXT-Polaris // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef POLARIS__TYPES__ENTITY_HPP_ #define POLARIS__TYPES__ENTITY_HPP_ #include <geometry_msgs/msg/pose.hpp> #include <string> #include <vector> namespace polaris { namespace types { class Entity { public : Entity () {} explicit Entity ( geometry_msgs :: msg :: Pose pose , std :: vector < std :: string > type , std :: vector < geometry_msgs :: msg :: Point > polygon ) { this -> pose = pose ; this -> type = type ; this -> polygon = polygon ; } explicit Entity ( geometry_msgs :: msg :: Pose pose , std :: string type , std :: vector < geometry_msgs :: msg :: Point > polygon ) { this -> pose = pose ; this -> type = { type }; this -> polygon = polygon ; } geometry_msgs :: msg :: Pose pose ; std :: vector < std :: string > type ; std :: vector < geometry_msgs :: msg :: Point > polygon ; }; } // namespace types } // namespace polaris #endif // POLARIS__TYPES__ENTITY_HPP_ Updated on 26 December 2020 at 00:59:10 UTC","title":"/home/runner/work/polaris/polaris/include/polaris/types/entity.hpp"},{"location":"doxygen/markdown/Files/entity_8hpp/#homerunnerworkpolarispolarisincludepolaristypesentityhpp","text":"","title":"/home/runner/work/polaris/polaris/include/polaris/types/entity.hpp"},{"location":"doxygen/markdown/Files/entity_8hpp/#namespaces","text":"Name polaris::types polaris","title":"Namespaces"},{"location":"doxygen/markdown/Files/entity_8hpp/#classes","text":"Name class polaris::types::Entity","title":"Classes"},{"location":"doxygen/markdown/Files/entity_8hpp/#source-code","text":"// Copyright (c) 2020, OUXT-Polaris // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef POLARIS__TYPES__ENTITY_HPP_ #define POLARIS__TYPES__ENTITY_HPP_ #include <geometry_msgs/msg/pose.hpp> #include <string> #include <vector> namespace polaris { namespace types { class Entity { public : Entity () {} explicit Entity ( geometry_msgs :: msg :: Pose pose , std :: vector < std :: string > type , std :: vector < geometry_msgs :: msg :: Point > polygon ) { this -> pose = pose ; this -> type = type ; this -> polygon = polygon ; } explicit Entity ( geometry_msgs :: msg :: Pose pose , std :: string type , std :: vector < geometry_msgs :: msg :: Point > polygon ) { this -> pose = pose ; this -> type = { type }; this -> polygon = polygon ; } geometry_msgs :: msg :: Pose pose ; std :: vector < std :: string > type ; std :: vector < geometry_msgs :: msg :: Point > polygon ; }; } // namespace types } // namespace polaris #endif // POLARIS__TYPES__ENTITY_HPP_ Updated on 26 December 2020 at 00:59:10 UTC","title":"Source code"},{"location":"doxygen/markdown/Files/example_8cpp/","text":"/home/runner/work/polaris/polaris/src/example/example.cpp # Functions # Name int main () Functions Documentation # function main # int main () Source code # // Copyright (c) 2020, OUXT-Polaris // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #include <polaris/parser/parser.hpp> #include <iostream> #include <string> #include <vector> int main () { polaris :: Parser parser ( true ); /* if (parser.evaluate(\"let a = 1.0;\")) { std::cout << \"evaluate succeced\" << std::endl; auto a_value = parser.getValue<double>(\"a\"); if (a_value) { std::cout << \"a = \" << a_value.get() << std::endl; } } else { std::cout << \"evaluate failed\" << std::endl; } if (parser.evaluate(\"let w = 1.0;let a = quaternion(double(0.0),0,0.0,w);\")) { std::cout << \"evaluate succeced\" << std::endl; auto a_value = parser.getValue<geometry_msgs::msg::Quaternion>(\"a\"); if (a_value) { std::cout << \"a.x = \" << a_value.get().x << std::endl; std::cout << \"a.y = \" << a_value.get().y << std::endl; std::cout << \"a.z = \" << a_value.get().z << std::endl; std::cout << \"a.w = \" << a_value.get().w << std::endl; } } std::string code = R\"(let a = entity(pose(point(1,2,3),quaternion(0,0,0,1)), [\"bouy\"], [point(0,1,2), point(2,3,4), point(3,2,3)]); let b = entity(pose(point(1,2,3),quaternion(0,0,0,1)), [\"bouy\"], [point(0,1,2), point(2,3,4), point(3,2,3)]); let c = [a,b];)\"; if (parser.evaluate(code)) { std::cout << \"evaluate succeced\" << std::endl; auto a_value = parser.getValue<polaris::types::Entity>(\"a\"); if (a_value) { std::cout << a_value->pose.position.x << std::endl; std::cout << a_value->pose.position.y << std::endl; std::cout << a_value->pose.position.z << std::endl; } auto c_value = parser.getValue<std::vector<polaris::types::Entity>>(\"c\"); if (c_value) { std::cout << c_value->size() << std::endl; } } */ std :: string code = R \" ( let a = true; ) \" ; parser . evaluate ( code ); const auto a = parser . getValue < bool > ( \"a\" ); if ( a ) { if ( a . get ()) { std :: cout << \"true\" << std :: endl ; } else { std :: cout << \"false\" << std :: endl ; } } } Updated on 26 December 2020 at 00:59:10 UTC","title":"/home/runner/work/polaris/polaris/src/example/example.cpp"},{"location":"doxygen/markdown/Files/example_8cpp/#homerunnerworkpolarispolarissrcexampleexamplecpp","text":"","title":"/home/runner/work/polaris/polaris/src/example/example.cpp"},{"location":"doxygen/markdown/Files/example_8cpp/#functions","text":"Name int main ()","title":"Functions"},{"location":"doxygen/markdown/Files/example_8cpp/#functions-documentation","text":"","title":"Functions Documentation"},{"location":"doxygen/markdown/Files/example_8cpp/#function-main","text":"int main ()","title":"function main"},{"location":"doxygen/markdown/Files/example_8cpp/#source-code","text":"// Copyright (c) 2020, OUXT-Polaris // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #include <polaris/parser/parser.hpp> #include <iostream> #include <string> #include <vector> int main () { polaris :: Parser parser ( true ); /* if (parser.evaluate(\"let a = 1.0;\")) { std::cout << \"evaluate succeced\" << std::endl; auto a_value = parser.getValue<double>(\"a\"); if (a_value) { std::cout << \"a = \" << a_value.get() << std::endl; } } else { std::cout << \"evaluate failed\" << std::endl; } if (parser.evaluate(\"let w = 1.0;let a = quaternion(double(0.0),0,0.0,w);\")) { std::cout << \"evaluate succeced\" << std::endl; auto a_value = parser.getValue<geometry_msgs::msg::Quaternion>(\"a\"); if (a_value) { std::cout << \"a.x = \" << a_value.get().x << std::endl; std::cout << \"a.y = \" << a_value.get().y << std::endl; std::cout << \"a.z = \" << a_value.get().z << std::endl; std::cout << \"a.w = \" << a_value.get().w << std::endl; } } std::string code = R\"(let a = entity(pose(point(1,2,3),quaternion(0,0,0,1)), [\"bouy\"], [point(0,1,2), point(2,3,4), point(3,2,3)]); let b = entity(pose(point(1,2,3),quaternion(0,0,0,1)), [\"bouy\"], [point(0,1,2), point(2,3,4), point(3,2,3)]); let c = [a,b];)\"; if (parser.evaluate(code)) { std::cout << \"evaluate succeced\" << std::endl; auto a_value = parser.getValue<polaris::types::Entity>(\"a\"); if (a_value) { std::cout << a_value->pose.position.x << std::endl; std::cout << a_value->pose.position.y << std::endl; std::cout << a_value->pose.position.z << std::endl; } auto c_value = parser.getValue<std::vector<polaris::types::Entity>>(\"c\"); if (c_value) { std::cout << c_value->size() << std::endl; } } */ std :: string code = R \" ( let a = true; ) \" ; parser . evaluate ( code ); const auto a = parser . getValue < bool > ( \"a\" ); if ( a ) { if ( a . get ()) { std :: cout << \"true\" << std :: endl ; } else { std :: cout << \"false\" << std :: endl ; } } } Updated on 26 December 2020 at 00:59:10 UTC","title":"Source code"},{"location":"doxygen/markdown/Files/exception_8hpp/","text":"/home/runner/work/polaris/polaris/include/polaris/exception.hpp # Namespaces # Name polaris Classes # Name class polaris::EvaluationError Defines # Name POLARIS_THROW_EVALUATION_ERROR (ast, description) Macro Documentation # define POLARIS_THROW_EVALUATION_ERROR # #define POLARIS_THROW_EVALUATION_ERROR( ast , description ) throw [ polaris :: EvaluationError ]( / polaris / doxygen / markdown / Classes / classpolaris_1_1EvaluationError )( ast , \\ description , \\ __FILE__ , \\ __LINE__ ); Source code # // Copyright (c) 2020, OUXT-Polaris // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef POLARIS__EXCEPTION_HPP_ #define POLARIS__EXCEPTION_HPP_ #include <peglib.h> #include <memory> #include <exception> #include <iostream> #include <sstream> #include <string> namespace polaris { class EvaluationError : public std :: runtime_error { public : EvaluationError ( std :: shared_ptr < peg :: Ast > ast , std :: string description , const char * file , int line ) : std :: runtime_error (( \" \\n ast => \\n \" + peg :: ast_to_s ( ast ) + \" \\n description => \" + description + \" \\n file => \" + file + \" \\n line => \" + std :: to_string ( line ) ). c_str ()), ast_string ( peg :: ast_to_s ( ast )), description ( description ) {} const std :: string ast_string ; const std :: string description ; }; } // namespace polaris #define POLARIS_THROW_EVALUATION_ERROR(ast, description) throw polaris::EvaluationError(ast, \\ description, \\ __FILE__, \\ __LINE__); #endif // POLARIS__EXCEPTION_HPP_ Updated on 26 December 2020 at 00:59:10 UTC","title":"/home/runner/work/polaris/polaris/include/polaris/exception.hpp"},{"location":"doxygen/markdown/Files/exception_8hpp/#homerunnerworkpolarispolarisincludepolarisexceptionhpp","text":"","title":"/home/runner/work/polaris/polaris/include/polaris/exception.hpp"},{"location":"doxygen/markdown/Files/exception_8hpp/#namespaces","text":"Name polaris","title":"Namespaces"},{"location":"doxygen/markdown/Files/exception_8hpp/#classes","text":"Name class polaris::EvaluationError","title":"Classes"},{"location":"doxygen/markdown/Files/exception_8hpp/#defines","text":"Name POLARIS_THROW_EVALUATION_ERROR (ast, description)","title":"Defines"},{"location":"doxygen/markdown/Files/exception_8hpp/#macro-documentation","text":"","title":"Macro Documentation"},{"location":"doxygen/markdown/Files/exception_8hpp/#define-polaris_throw_evaluation_error","text":"#define POLARIS_THROW_EVALUATION_ERROR( ast , description ) throw [ polaris :: EvaluationError ]( / polaris / doxygen / markdown / Classes / classpolaris_1_1EvaluationError )( ast , \\ description , \\ __FILE__ , \\ __LINE__ );","title":"define POLARIS_THROW_EVALUATION_ERROR"},{"location":"doxygen/markdown/Files/exception_8hpp/#source-code","text":"// Copyright (c) 2020, OUXT-Polaris // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef POLARIS__EXCEPTION_HPP_ #define POLARIS__EXCEPTION_HPP_ #include <peglib.h> #include <memory> #include <exception> #include <iostream> #include <sstream> #include <string> namespace polaris { class EvaluationError : public std :: runtime_error { public : EvaluationError ( std :: shared_ptr < peg :: Ast > ast , std :: string description , const char * file , int line ) : std :: runtime_error (( \" \\n ast => \\n \" + peg :: ast_to_s ( ast ) + \" \\n description => \" + description + \" \\n file => \" + file + \" \\n line => \" + std :: to_string ( line ) ). c_str ()), ast_string ( peg :: ast_to_s ( ast )), description ( description ) {} const std :: string ast_string ; const std :: string description ; }; } // namespace polaris #define POLARIS_THROW_EVALUATION_ERROR(ast, description) throw polaris::EvaluationError(ast, \\ description, \\ __FILE__, \\ __LINE__); #endif // POLARIS__EXCEPTION_HPP_ Updated on 26 December 2020 at 00:59:10 UTC","title":"Source code"},{"location":"doxygen/markdown/Files/functions_8cpp/","text":"/home/runner/work/polaris/polaris/src/built_in_functions/functions.cpp # Namespaces # Name polaris::built_in_functions polaris Source code # // Copyright (c) 2020, OUXT-Polaris // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #include <polaris/types/type_base.hpp> #include <polaris/built_in_functions/functions.hpp> #include <polaris/exception.hpp> #include <quaternion_operation/quaternion_operation.h> #include <geometry_msgs/msg/quaternion.hpp> #include <geometry_msgs/msg/point.hpp> #include <boost/optional.hpp> #include <boost/any.hpp> #include <functional> #include <unordered_map> #include <memory> #include <string> #include <vector> namespace polaris { namespace built_in_functions { boost :: any Functions :: fetchVariable ( std :: shared_ptr < peg :: Ast > ast ) { if ( variables_ . count ( ast -> token ) == 0 ) { POLARIS_THROW_EVALUATION_ERROR ( ast -> nodes [ 0 ], \"variable \" + ast -> token + \" did not defined yet.\" ); } return variables_ [ ast -> token ]; } boost :: any Functions :: constructBoolean ( std :: shared_ptr < peg :: Ast > ast ) { if ( ast -> name == \"BOOLEAN\" ) { types :: TypeBase < bool > bool_value ; if ( ast -> token == \"true\" ) { bool_value . setValue ( true ); } else if ( ast -> token == \"false\" ) { bool_value . setValue ( false ); } else { POLARIS_THROW_EVALUATION_ERROR ( ast , \"bool value should be true or false\" ); } return bool_value ; } return boost :: none ; } boost :: any Functions :: constructEntity ( std :: shared_ptr < peg :: Ast > ast ) { auto pose_value = evaluate ( ast -> nodes [ 0 ] -> name , ast -> nodes [ 0 ]); geometry_msgs :: msg :: Pose pose ; if ( pose_value . type () == typeid ( types :: TypeBase < geometry_msgs :: msg :: Pose > )) { pose = boost :: any_cast < types :: TypeBase < geometry_msgs :: msg :: Pose >> ( pose_value ). getValue (); } else { POLARIS_THROW_EVALUATION_ERROR ( ast -> nodes [ 0 ], \"failed to parse pose\" ); } auto type_value = evaluate ( ast -> nodes [ 1 ] -> name , ast -> nodes [ 1 ]); std :: string type ; std :: vector < std :: string > types ; if ( type_value . type () == typeid ( types :: TypeBase < std :: string > )) { type = boost :: any_cast < types :: TypeBase < std :: string >> ( type_value ). getValue (); } else if ( type_value . type () == typeid ( types :: TypeBase < std :: vector < std :: string >> )) { types = boost :: any_cast < types :: TypeBase < std :: vector < std :: string >>> ( type_value ). getValue (); } else { POLARIS_THROW_EVALUATION_ERROR ( ast -> nodes [ 1 ], \"failed to parse types\" ); } auto polygon_value = evaluate ( ast -> nodes [ 2 ] -> name , ast -> nodes [ 2 ]); std :: vector < geometry_msgs :: msg :: Point > polygon ; if ( polygon_value . type () == typeid ( types :: TypeBase < std :: vector < geometry_msgs :: msg :: Point >> )) { polygon = boost :: any_cast < types :: TypeBase < std :: vector < geometry_msgs :: msg :: Point >>> ( polygon_value ). getValue (); } else { POLARIS_THROW_EVALUATION_ERROR ( ast -> nodes [ 2 ], \"failed to parse polygon\" ); } if ( types . size () == 0 ) { return types :: TypeBase < polaris :: types :: Entity > ( polaris :: types :: Entity ( pose , type , polygon )); } else { return types :: TypeBase < polaris :: types :: Entity > ( polaris :: types :: Entity ( pose , types , polygon )); } return boost :: none ; } boost :: any Functions :: constructArray ( std :: shared_ptr < peg :: Ast > ast ) { if ( ast -> nodes . size () == 0 ) { POLARIS_THROW_EVALUATION_ERROR ( ast , \"array is empty\" ); } const auto first_value = evaluate ( ast -> nodes [ 0 ] -> name , ast -> nodes [ 0 ]); const auto & value_type = first_value . type (); if ( value_type == typeid ( types :: TypeBase < int > )) { types :: TypeBase < std :: vector < int >> array ; std :: vector < int > array_value ; for ( const auto & node : ast -> nodes ) { auto value = evaluate ( node -> name , node ); if ( value . type () == typeid ( types :: TypeBase < int > )) { array_value . emplace_back ( boost :: any_cast < types :: TypeBase < int >> ( value ). getValue ()); } else { POLARIS_THROW_EVALUATION_ERROR ( ast , \"array value is not int\" ); } } array . setValue ( array_value ); return array ; } if ( value_type == typeid ( types :: TypeBase < double > )) { types :: TypeBase < std :: vector < double >> array ; std :: vector < double > array_value ; for ( const auto & node : ast -> nodes ) { auto value = evaluate ( node -> name , node ); if ( value . type () == typeid ( types :: TypeBase < double > )) { array_value . emplace_back ( boost :: any_cast < types :: TypeBase < double >> ( value ). getValue ()); } else { POLARIS_THROW_EVALUATION_ERROR ( ast , \"array value is not double\" ); } } array . setValue ( array_value ); return array ; } if ( value_type == typeid ( types :: TypeBase < std :: string > )) { types :: TypeBase < std :: vector < std :: string >> array ; std :: vector < std :: string > array_value ; for ( const auto & node : ast -> nodes ) { auto value = evaluate ( node -> name , node ); if ( value . type () == typeid ( types :: TypeBase < std :: string > )) { array_value . emplace_back ( boost :: any_cast < types :: TypeBase < std :: string >> ( value ). getValue ()); } else { POLARIS_THROW_EVALUATION_ERROR ( ast , \"array value is not string\" ); } } array . setValue ( array_value ); return array ; } if ( value_type == typeid ( types :: TypeBase < bool > )) { types :: TypeBase < std :: vector < bool >> array ; std :: vector < bool > array_value ; for ( const auto & node : ast -> nodes ) { auto value = evaluate ( node -> name , node ); if ( value . type () == typeid ( types :: TypeBase < bool > )) { array_value . emplace_back ( boost :: any_cast < types :: TypeBase < bool >> ( value ). getValue ()); } else { POLARIS_THROW_EVALUATION_ERROR ( ast , \"array value is not bool\" ); } } array . setValue ( array_value ); return array ; } if ( value_type == typeid ( types :: TypeBase < geometry_msgs :: msg :: Quaternion > )) { types :: TypeBase < std :: vector < geometry_msgs :: msg :: Quaternion >> array ; std :: vector < geometry_msgs :: msg :: Quaternion > array_value ; for ( const auto & node : ast -> nodes ) { auto value = evaluate ( node -> name , node ); if ( value . type () == typeid ( types :: TypeBase < geometry_msgs :: msg :: Quaternion > )) { array_value . emplace_back ( boost :: any_cast < types :: TypeBase < geometry_msgs :: msg :: Quaternion >> ( value ). getValue ()); } else { POLARIS_THROW_EVALUATION_ERROR ( ast , \"array value is not quaternion\" ); } } array . setValue ( array_value ); return array ; } if ( value_type == typeid ( types :: TypeBase < geometry_msgs :: msg :: Point > )) { types :: TypeBase < std :: vector < geometry_msgs :: msg :: Point >> array ; std :: vector < geometry_msgs :: msg :: Point > array_value ; for ( const auto & node : ast -> nodes ) { auto value = evaluate ( node -> name , node ); if ( value . type () == typeid ( types :: TypeBase < geometry_msgs :: msg :: Point > )) { array_value . emplace_back ( boost :: any_cast < types :: TypeBase < geometry_msgs :: msg :: Point >> ( value ). getValue ()); } else { POLARIS_THROW_EVALUATION_ERROR ( ast , \"array value is not point\" ); } } array . setValue ( array_value ); return array ; } if ( value_type == typeid ( types :: TypeBase < geometry_msgs :: msg :: Pose > )) { types :: TypeBase < std :: vector < geometry_msgs :: msg :: Pose >> array ; std :: vector < geometry_msgs :: msg :: Pose > array_value ; for ( const auto & node : ast -> nodes ) { auto value = evaluate ( node -> name , node ); if ( value . type () == typeid ( types :: TypeBase < geometry_msgs :: msg :: Pose > )) { array_value . emplace_back ( boost :: any_cast < types :: TypeBase < geometry_msgs :: msg :: Pose >> ( value ). getValue ()); } else { POLARIS_THROW_EVALUATION_ERROR ( ast , \"array value is not pose\" ); } } array . setValue ( array_value ); return array ; } if ( value_type == typeid ( types :: TypeBase < types :: Entity > )) { types :: TypeBase < std :: vector < types :: Entity >> array ; std :: vector < types :: Entity > array_value ; for ( const auto & node : ast -> nodes ) { auto value = evaluate ( node -> name , node ); if ( value . type () == typeid ( types :: TypeBase < types :: Entity > )) { array_value . emplace_back ( boost :: any_cast < types :: TypeBase < types :: Entity >> ( value ). getValue ()); } else { POLARIS_THROW_EVALUATION_ERROR ( ast , \"array value is not pose\" ); } } array . setValue ( array_value ); return array ; } return boost :: none ; } boost :: any Functions :: constructString ( std :: shared_ptr < peg :: Ast > ast ) { if ( ast -> name == \"STRING\" ) { types :: TypeBase < std :: string > str_value ; str_value . setValue ( ast -> token ); return str_value ; } return boost :: none ; } boost :: any Functions :: constructInteger ( std :: shared_ptr < peg :: Ast > ast ) { if ( ast -> name == \"INTEGER\" ) { try { types :: TypeBase < int > int_value ; int_value . setValue ( std :: stoi ( ast -> token )); return int_value ; } catch ( std :: invalid_argument ) { POLARIS_THROW_EVALUATION_ERROR ( ast , \"failed to parse token into int value, std::invalid_argument\" ); } catch ( std :: out_of_range ) { POLARIS_THROW_EVALUATION_ERROR ( ast , \"failed to parse token into int value, std::out_of_range\" ); } } return boost :: none ; } boost :: any Functions :: constructDouble ( std :: shared_ptr < peg :: Ast > ast ) { if ( ast -> name == \"DOUBLE\" || ast -> name == \"INTEGER\" ) { try { types :: TypeBase < double > double_value ; double_value . setValue ( std :: stod ( ast -> token )); return double_value ; } catch ( std :: invalid_argument ) { POLARIS_THROW_EVALUATION_ERROR ( ast , \"failed to parse token into double value, std::invalid_argument\" ); } catch ( std :: out_of_range ) { POLARIS_THROW_EVALUATION_ERROR ( ast , \"failed to parse token into double value, std::out_of_range\" ); } } return boost :: none ; } boost :: any Functions :: constructPose ( std :: shared_ptr < peg :: Ast > ast ) { geometry_msgs :: msg :: Pose pose ; if ( ast -> name == \"ARGUMENTS\" ) { if ( ast -> nodes [ 0 ] -> name == \"CALL\" ) { if ( ast -> nodes [ 0 ] -> nodes [ 0 ] -> name == \"IDENTIFIER\" ) { boost :: any val = evaluate ( ast -> nodes [ 0 ] -> nodes [ 0 ] -> token , ast -> nodes [ 0 ]); if ( ast -> nodes [ 0 ] -> nodes [ 0 ] -> token == \"point\" ) { if ( val . type () == typeid ( types :: TypeBase < geometry_msgs :: msg :: Point > )) { auto p = boost :: any_cast < types :: TypeBase < geometry_msgs :: msg :: Point >> ( val ). getValue (); pose . position = p ; } else { POLARIS_THROW_EVALUATION_ERROR ( ast , \"constracting point type failed\" ); } } else { POLARIS_THROW_EVALUATION_ERROR ( ast , \"first argument shold be point type\" ); } } } else if ( ast -> nodes [ 0 ] -> name == \"IDENTIFIER\" ) { if ( variables_ . count ( ast -> nodes [ 0 ] -> token ) == 0 ) { POLARIS_THROW_EVALUATION_ERROR ( ast , \"variable \" + ast -> nodes [ 0 ] -> token + \" did not difined.\" ); } if ( variables_ [ ast -> nodes [ 0 ] -> token ]. type () == typeid ( types :: TypeBase < geometry_msgs :: msg :: Point > )) { pose . position = boost :: any_cast < types :: TypeBase < geometry_msgs :: msg :: Point >> ( variables_ [ ast -> nodes [ 0 ] -> token ]). getValue (); } } else { POLARIS_THROW_EVALUATION_ERROR ( ast , \"name of the node is invalid\" ); } if ( ast -> nodes [ 1 ] -> name == \"CALL\" ) { if ( ast -> nodes [ 1 ] -> nodes [ 0 ] -> name == \"IDENTIFIER\" ) { boost :: any val = evaluate ( ast -> nodes [ 1 ] -> nodes [ 0 ] -> token , ast -> nodes [ 1 ]); if ( ast -> nodes [ 1 ] -> nodes [ 0 ] -> token == \"quaternion\" ) { if ( val . type () == typeid ( types :: TypeBase < geometry_msgs :: msg :: Quaternion > )) { auto q = boost :: any_cast < types :: TypeBase < geometry_msgs :: msg :: Quaternion >> ( val ). getValue (); pose . orientation = q ; } else { POLARIS_THROW_EVALUATION_ERROR ( ast , \"constracting quaternion type failed\" ); } } else { POLARIS_THROW_EVALUATION_ERROR ( ast , \"second argument shold be quaternion type\" ); } } } else if ( ast -> nodes [ 1 ] -> name == \"IDENTIFIER\" ) { if ( variables_ . count ( ast -> nodes [ 1 ] -> token ) == 0 ) { POLARIS_THROW_EVALUATION_ERROR ( ast , \"variable \" + ast -> nodes [ 1 ] -> token + \" did not difined.\" ); } if ( variables_ [ ast -> nodes [ 1 ] -> token ]. type () == typeid ( types :: TypeBase < geometry_msgs :: msg :: Quaternion > )) { pose . orientation = boost :: any_cast < types :: TypeBase < geometry_msgs :: msg :: Quaternion >> ( variables_ [ ast -> nodes [ 1 ] -> token ]). getValue (); } } else { POLARIS_THROW_EVALUATION_ERROR ( ast , \"name of the node is invalid\" ); } } types :: TypeBase < geometry_msgs :: msg :: Pose > pose_value ; pose_value . setValue ( pose ); return pose_value ; } boost :: any Functions :: constructPoint ( std :: shared_ptr < peg :: Ast > ast ) { geometry_msgs :: msg :: Point point ; if ( ast -> name == \"ARGUMENTS\" ) { try { if ( ast -> nodes [ 0 ] -> name == \"CALL\" ) { auto val = evaluate ( ast -> nodes [ 0 ] -> nodes [ 0 ] -> token , ast -> nodes [ 0 ] -> nodes [ 1 ]); if ( val . type () != typeid ( types :: TypeBase < double > )) { POLARIS_THROW_EVALUATION_ERROR ( ast , \"failed to interprit as double value\" ); } point . x = boost :: any_cast < types :: TypeBase < double >> ( val ). getValue (); } else if ( ast -> nodes [ 0 ] -> name == \"IDENTIFIER\" ) { point . x = boost :: any_cast < types :: TypeBase < double >> ( variables_ [ ast -> nodes [ 0 ] -> token ]). getValue (); } else { point . x = boost :: any_cast < types :: TypeBase < double >> ( constructDouble ( ast -> nodes [ 0 ])). getValue (); } if ( ast -> nodes [ 1 ] -> name == \"CALL\" ) { auto val = evaluate ( ast -> nodes [ 1 ] -> nodes [ 0 ] -> token , ast -> nodes [ 1 ] -> nodes [ 1 ]); if ( val . type () != typeid ( types :: TypeBase < double > )) { POLARIS_THROW_EVALUATION_ERROR ( ast , \"failed to interprit as double value\" ); } point . y = boost :: any_cast < types :: TypeBase < double >> ( val ). getValue (); } else if ( ast -> nodes [ 1 ] -> name == \"IDENTIFIER\" ) { point . y = boost :: any_cast < types :: TypeBase < double >> ( variables_ [ ast -> nodes [ 1 ] -> token ]). getValue (); } else { point . y = boost :: any_cast < types :: TypeBase < double >> ( constructDouble ( ast -> nodes [ 1 ])). getValue (); } if ( ast -> nodes [ 2 ] -> name == \"CALL\" ) { auto val = evaluate ( ast -> nodes [ 2 ] -> nodes [ 0 ] -> token , ast -> nodes [ 2 ] -> nodes [ 1 ]); if ( val . type () != typeid ( types :: TypeBase < double > )) { POLARIS_THROW_EVALUATION_ERROR ( ast , \"failed to interprit as double value\" ); } point . z = boost :: any_cast < types :: TypeBase < double >> ( val ). getValue (); } else if ( ast -> nodes [ 2 ] -> name == \"IDENTIFIER\" ) { point . z = boost :: any_cast < types :: TypeBase < double >> ( variables_ [ ast -> nodes [ 2 ] -> token ]). getValue (); } else { point . z = boost :: any_cast < types :: TypeBase < double >> ( constructDouble ( ast -> nodes [ 2 ])). getValue (); } types :: TypeBase < geometry_msgs :: msg :: Point > point_value ; point_value . setValue ( point ); return point_value ; } catch ( boost :: bad_any_cast ) { POLARIS_THROW_EVALUATION_ERROR ( ast , \"failed to cast as double value in constructing point, boost::bad_any_cast\" ); } } return boost :: none ; } boost :: any Functions :: constructQuaternionFromRpy ( std :: shared_ptr < peg :: Ast > ast ) { geometry_msgs :: msg :: Vector3 rpy ; if ( ast -> name == \"ARGUMENTS\" ) { try { if ( ast -> nodes [ 0 ] -> name == \"CALL\" ) { auto val = evaluate ( ast -> nodes [ 0 ] -> nodes [ 0 ] -> token , ast -> nodes [ 0 ] -> nodes [ 1 ]); if ( val . type () != typeid ( types :: TypeBase < double > )) { POLARIS_THROW_EVALUATION_ERROR ( ast , \"failed to interprit as double value\" ); } rpy . x = boost :: any_cast < types :: TypeBase < double >> ( val ). getValue (); } else if ( ast -> nodes [ 0 ] -> name == \"IDENTIFIER\" ) { rpy . x = boost :: any_cast < types :: TypeBase < double >> ( variables_ [ ast -> nodes [ 0 ] -> token ]). getValue (); } else { rpy . x = boost :: any_cast < types :: TypeBase < double >> ( constructDouble ( ast -> nodes [ 0 ])). getValue (); } if ( ast -> nodes [ 1 ] -> name == \"CALL\" ) { auto val = evaluate ( ast -> nodes [ 1 ] -> nodes [ 0 ] -> token , ast -> nodes [ 1 ] -> nodes [ 1 ]); if ( val . type () != typeid ( types :: TypeBase < double > )) { POLARIS_THROW_EVALUATION_ERROR ( ast , \"failed to interprit as double value\" ); } rpy . y = boost :: any_cast < types :: TypeBase < double >> ( val ). getValue (); } else if ( ast -> nodes [ 1 ] -> name == \"IDENTIFIER\" ) { rpy . y = boost :: any_cast < types :: TypeBase < double >> ( variables_ [ ast -> nodes [ 1 ] -> token ]). getValue (); } else { rpy . y = boost :: any_cast < types :: TypeBase < double >> ( constructDouble ( ast -> nodes [ 1 ])). getValue (); } if ( ast -> nodes [ 2 ] -> name == \"CALL\" ) { auto val = evaluate ( ast -> nodes [ 2 ] -> nodes [ 0 ] -> token , ast -> nodes [ 2 ] -> nodes [ 1 ]); if ( val . type () != typeid ( types :: TypeBase < double > )) { POLARIS_THROW_EVALUATION_ERROR ( ast , \"failed to interprit as double value\" ); } rpy . z = boost :: any_cast < types :: TypeBase < double >> ( val ). getValue (); } else if ( ast -> nodes [ 2 ] -> name == \"IDENTIFIER\" ) { rpy . z = boost :: any_cast < types :: TypeBase < double >> ( variables_ [ ast -> nodes [ 2 ] -> token ]). getValue (); } else { rpy . z = boost :: any_cast < types :: TypeBase < double >> ( constructDouble ( ast -> nodes [ 2 ])). getValue (); } types :: TypeBase < geometry_msgs :: msg :: Quaternion > quat_value ; geometry_msgs :: msg :: Quaternion quat = quaternion_operation :: convertEulerAngleToQuaternion ( rpy ); quat_value . setValue ( quat ); return quat_value ; } catch ( boost :: bad_any_cast ) { POLARIS_THROW_EVALUATION_ERROR ( ast , \"failed to cast as double value in constructing quaternion, boost::bad_any_cast\" ); } } return boost :: none ; } boost :: any Functions :: constructQuaternion ( std :: shared_ptr < peg :: Ast > ast ) { geometry_msgs :: msg :: Quaternion quat ; if ( ast -> name == \"ARGUMENTS\" ) { try { if ( ast -> nodes [ 0 ] -> name == \"CALL\" ) { auto val = evaluate ( ast -> nodes [ 0 ] -> nodes [ 0 ] -> token , ast -> nodes [ 0 ] -> nodes [ 1 ]); if ( val . type () != typeid ( types :: TypeBase < double > )) { POLARIS_THROW_EVALUATION_ERROR ( ast , \"failed to interprit as double value\" ); } quat . x = boost :: any_cast < types :: TypeBase < double >> ( val ). getValue (); } else if ( ast -> nodes [ 0 ] -> name == \"IDENTIFIER\" ) { quat . x = boost :: any_cast < types :: TypeBase < double >> ( variables_ [ ast -> nodes [ 0 ] -> token ]). getValue (); } else { quat . x = boost :: any_cast < types :: TypeBase < double >> ( constructDouble ( ast -> nodes [ 0 ])). getValue (); } if ( ast -> nodes [ 1 ] -> name == \"CALL\" ) { auto val = evaluate ( ast -> nodes [ 1 ] -> nodes [ 0 ] -> token , ast -> nodes [ 1 ] -> nodes [ 1 ]); if ( val . type () != typeid ( types :: TypeBase < double > )) { POLARIS_THROW_EVALUATION_ERROR ( ast , \"failed to interprit as double value\" ); } quat . y = boost :: any_cast < types :: TypeBase < double >> ( val ). getValue (); } else if ( ast -> nodes [ 1 ] -> name == \"IDENTIFIER\" ) { quat . y = boost :: any_cast < types :: TypeBase < double >> ( variables_ [ ast -> nodes [ 1 ] -> token ]). getValue (); } else { quat . y = boost :: any_cast < types :: TypeBase < double >> ( constructDouble ( ast -> nodes [ 1 ])). getValue (); } if ( ast -> nodes [ 2 ] -> name == \"CALL\" ) { auto val = evaluate ( ast -> nodes [ 2 ] -> nodes [ 0 ] -> token , ast -> nodes [ 2 ] -> nodes [ 1 ]); if ( val . type () != typeid ( types :: TypeBase < double > )) { POLARIS_THROW_EVALUATION_ERROR ( ast , \"failed to interprit as double value\" ); } quat . z = boost :: any_cast < types :: TypeBase < double >> ( val ). getValue (); } else if ( ast -> nodes [ 2 ] -> name == \"IDENTIFIER\" ) { quat . z = boost :: any_cast < types :: TypeBase < double >> ( variables_ [ ast -> nodes [ 2 ] -> token ]). getValue (); } else { quat . z = boost :: any_cast < types :: TypeBase < double >> ( constructDouble ( ast -> nodes [ 2 ])). getValue (); } if ( ast -> nodes [ 3 ] -> name == \"CALL\" ) { auto val = evaluate ( ast -> nodes [ 3 ] -> nodes [ 0 ] -> token , ast -> nodes [ 3 ] -> nodes [ 1 ]); if ( val . type () != typeid ( types :: TypeBase < double > )) { POLARIS_THROW_EVALUATION_ERROR ( ast , \"failed to interprit as double value\" ); } quat . w = boost :: any_cast < types :: TypeBase < double >> ( val ). getValue (); } else if ( ast -> nodes [ 3 ] -> name == \"IDENTIFIER\" ) { quat . w = boost :: any_cast < types :: TypeBase < double >> ( variables_ [ ast -> nodes [ 3 ] -> token ]). getValue (); } else { quat . w = boost :: any_cast < types :: TypeBase < double >> ( constructDouble ( ast -> nodes [ 3 ])). getValue (); } types :: TypeBase < geometry_msgs :: msg :: Quaternion > quat_value ; quat_value . setValue ( quat ); return quat_value ; } catch ( boost :: bad_any_cast ) { POLARIS_THROW_EVALUATION_ERROR ( ast , \"failed to cast as double value in constructing quaternion, boost::bad_any_cast\" ); } } return boost :: none ; } boost :: any Functions :: multiplication ( std :: shared_ptr < peg :: Ast > ast ) { auto v0 = evaluate ( ast -> nodes [ 0 ] -> name , ast -> nodes [ 0 ]); auto v1 = evaluate ( ast -> nodes [ 2 ] -> name , ast -> nodes [ 2 ]); // (quaternion value) * (quaternion value) if ( v0 . type () == typeid ( types :: TypeBase < geometry_msgs :: msg :: Quaternion > ) && v1 . type () == typeid ( types :: TypeBase < geometry_msgs :: msg :: Quaternion > )) { types :: TypeBase < geometry_msgs :: msg :: Quaternion > ret ; ret . setValue ( boost :: any_cast < types :: TypeBase < geometry_msgs :: msg :: Quaternion >> ( v0 ). getValue () * boost :: any_cast < types :: TypeBase < geometry_msgs :: msg :: Quaternion >> ( v1 ). getValue ()); return ret ; } // (double value) * (double value) if ( v0 . type () == typeid ( types :: TypeBase < double > ) && v1 . type () == typeid ( types :: TypeBase < double > )) { types :: TypeBase < double > ret ; ret . setValue ( boost :: any_cast < types :: TypeBase < double >> ( v0 ). getValue () * boost :: any_cast < types :: TypeBase < double >> ( v1 ). getValue ()); return ret ; } // (int value) * (double value) if ( v0 . type () == typeid ( types :: TypeBase < int > ) && v1 . type () == typeid ( types :: TypeBase < double > )) { types :: TypeBase < double > ret ; ret . setValue ( boost :: any_cast < types :: TypeBase < int >> ( v0 ). getValue () * boost :: any_cast < types :: TypeBase < double >> ( v1 ). getValue ()); return ret ; } // (double value) * (int value) if ( v0 . type () == typeid ( types :: TypeBase < double > ) && v1 . type () == typeid ( types :: TypeBase < int > )) { types :: TypeBase < double > ret ; ret . setValue ( boost :: any_cast < types :: TypeBase < double >> ( v0 ). getValue () * boost :: any_cast < types :: TypeBase < int >> ( v1 ). getValue ()); return ret ; } // (int value) * (int value) if ( v0 . type () == typeid ( types :: TypeBase < int > ) && v1 . type () == typeid ( types :: TypeBase < int > )) { types :: TypeBase < int > ret ; ret . setValue ( boost :: any_cast < types :: TypeBase < int >> ( v0 ). getValue () * boost :: any_cast < types :: TypeBase < int >> ( v1 ). getValue ()); return ret ; } POLARIS_THROW_EVALUATION_ERROR ( ast , \"multiplication operators did not defined yet.\" ); } boost :: any Functions :: division ( std :: shared_ptr < peg :: Ast > ast ) { auto v0 = evaluate ( ast -> nodes [ 0 ] -> name , ast -> nodes [ 0 ]); auto v1 = evaluate ( ast -> nodes [ 2 ] -> name , ast -> nodes [ 2 ]); // (double value) * (double value) if ( v0 . type () == typeid ( types :: TypeBase < double > ) && v1 . type () == typeid ( types :: TypeBase < double > )) { types :: TypeBase < double > ret ; ret . setValue ( boost :: any_cast < types :: TypeBase < double >> ( v0 ). getValue () / boost :: any_cast < types :: TypeBase < double >> ( v1 ). getValue ()); return ret ; } // (int value) * (double value) if ( v0 . type () == typeid ( types :: TypeBase < int > ) && v1 . type () == typeid ( types :: TypeBase < double > )) { types :: TypeBase < double > ret ; ret . setValue ( boost :: any_cast < types :: TypeBase < int >> ( v0 ). getValue () / boost :: any_cast < types :: TypeBase < double >> ( v1 ). getValue ()); return ret ; } // (double value) * (int value) if ( v0 . type () == typeid ( types :: TypeBase < double > ) && v1 . type () == typeid ( types :: TypeBase < int > )) { types :: TypeBase < double > ret ; ret . setValue ( boost :: any_cast < types :: TypeBase < double >> ( v0 ). getValue () / boost :: any_cast < types :: TypeBase < int >> ( v1 ). getValue ()); return ret ; } // (int value) * (int value) if ( v0 . type () == typeid ( types :: TypeBase < int > ) && v1 . type () == typeid ( types :: TypeBase < int > )) { types :: TypeBase < int > ret ; ret . setValue ( boost :: any_cast < types :: TypeBase < int >> ( v0 ). getValue () / boost :: any_cast < types :: TypeBase < int >> ( v1 ). getValue ()); return ret ; } POLARIS_THROW_EVALUATION_ERROR ( ast , \"division operators did not defined yet.\" ); } boost :: any Functions :: subtraction ( std :: shared_ptr < peg :: Ast > ast ) { auto v0 = evaluate ( ast -> nodes [ 0 ] -> name , ast -> nodes [ 0 ]); auto v1 = evaluate ( ast -> nodes [ 2 ] -> name , ast -> nodes [ 2 ]); // (double value) - (double value) if ( v0 . type () == typeid ( types :: TypeBase < double > ) && v1 . type () == typeid ( types :: TypeBase < double > )) { types :: TypeBase < double > ret ; ret . setValue ( boost :: any_cast < types :: TypeBase < double >> ( v0 ). getValue () - boost :: any_cast < types :: TypeBase < double >> ( v1 ). getValue ()); return ret ; } // (int value) - (double value) if ( v0 . type () == typeid ( types :: TypeBase < int > ) && v1 . type () == typeid ( types :: TypeBase < double > )) { types :: TypeBase < double > ret ; ret . setValue ( static_cast < double > ( boost :: any_cast < types :: TypeBase < int >> ( v0 ). getValue ()) - boost :: any_cast < types :: TypeBase < double >> ( v1 ). getValue ()); return ret ; } // (double value) - (int value) if ( v0 . type () == typeid ( types :: TypeBase < double > ) && v1 . type () == typeid ( types :: TypeBase < int > )) { types :: TypeBase < double > ret ; ret . setValue ( boost :: any_cast < types :: TypeBase < double >> ( v0 ). getValue () - static_cast < double > ( boost :: any_cast < types :: TypeBase < int >> ( v1 ). getValue ())); return ret ; } // (int value) - (int value) if ( v0 . type () == typeid ( types :: TypeBase < double > ) && v1 . type () == typeid ( types :: TypeBase < int > )) { types :: TypeBase < int > ret ; ret . setValue ( boost :: any_cast < types :: TypeBase < int >> ( v0 ). getValue () - boost :: any_cast < types :: TypeBase < int >> ( v1 ). getValue ()); return ret ; } POLARIS_THROW_EVALUATION_ERROR ( ast , \"subcraction operators did not defined yet.\" ); } boost :: any Functions :: addition ( std :: shared_ptr < peg :: Ast > ast ) { auto v0 = evaluate ( ast -> nodes [ 0 ] -> name , ast -> nodes [ 0 ]); auto v1 = evaluate ( ast -> nodes [ 2 ] -> name , ast -> nodes [ 2 ]); // (double value) + (double value) if ( v0 . type () == typeid ( types :: TypeBase < double > ) && v1 . type () == typeid ( types :: TypeBase < double > )) { types :: TypeBase < double > ret ; ret . setValue ( boost :: any_cast < types :: TypeBase < double >> ( v0 ). getValue () + boost :: any_cast < types :: TypeBase < double >> ( v1 ). getValue ()); return ret ; } // (int value) + (double value) if ( v0 . type () == typeid ( types :: TypeBase < int > ) && v1 . type () == typeid ( types :: TypeBase < double > )) { types :: TypeBase < double > ret ; ret . setValue ( static_cast < double > ( boost :: any_cast < types :: TypeBase < int >> ( v0 ). getValue ()) + boost :: any_cast < types :: TypeBase < double >> ( v1 ). getValue ()); return ret ; } // (double value) + (int value) if ( v0 . type () == typeid ( types :: TypeBase < double > ) && v1 . type () == typeid ( types :: TypeBase < int > )) { types :: TypeBase < double > ret ; ret . setValue ( boost :: any_cast < types :: TypeBase < double >> ( v0 ). getValue () + static_cast < double > ( boost :: any_cast < types :: TypeBase < int >> ( v1 ). getValue ())); return ret ; } // (int value) + (int value) if ( v0 . type () == typeid ( types :: TypeBase < double > ) && v1 . type () == typeid ( types :: TypeBase < int > )) { types :: TypeBase < int > ret ; ret . setValue ( boost :: any_cast < types :: TypeBase < int >> ( v0 ). getValue () + boost :: any_cast < types :: TypeBase < int >> ( v1 ). getValue ()); return ret ; } POLARIS_THROW_EVALUATION_ERROR ( ast , \"addition operators did not defined yet.\" ); } } // namespace built_in_functions } // namespace polaris Updated on 26 December 2020 at 00:59:10 UTC","title":"/home/runner/work/polaris/polaris/src/built_in_functions/functions.cpp"},{"location":"doxygen/markdown/Files/functions_8cpp/#homerunnerworkpolarispolarissrcbuilt_in_functionsfunctionscpp","text":"","title":"/home/runner/work/polaris/polaris/src/built_in_functions/functions.cpp"},{"location":"doxygen/markdown/Files/functions_8cpp/#namespaces","text":"Name polaris::built_in_functions polaris","title":"Namespaces"},{"location":"doxygen/markdown/Files/functions_8cpp/#source-code","text":"// Copyright (c) 2020, OUXT-Polaris // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #include <polaris/types/type_base.hpp> #include <polaris/built_in_functions/functions.hpp> #include <polaris/exception.hpp> #include <quaternion_operation/quaternion_operation.h> #include <geometry_msgs/msg/quaternion.hpp> #include <geometry_msgs/msg/point.hpp> #include <boost/optional.hpp> #include <boost/any.hpp> #include <functional> #include <unordered_map> #include <memory> #include <string> #include <vector> namespace polaris { namespace built_in_functions { boost :: any Functions :: fetchVariable ( std :: shared_ptr < peg :: Ast > ast ) { if ( variables_ . count ( ast -> token ) == 0 ) { POLARIS_THROW_EVALUATION_ERROR ( ast -> nodes [ 0 ], \"variable \" + ast -> token + \" did not defined yet.\" ); } return variables_ [ ast -> token ]; } boost :: any Functions :: constructBoolean ( std :: shared_ptr < peg :: Ast > ast ) { if ( ast -> name == \"BOOLEAN\" ) { types :: TypeBase < bool > bool_value ; if ( ast -> token == \"true\" ) { bool_value . setValue ( true ); } else if ( ast -> token == \"false\" ) { bool_value . setValue ( false ); } else { POLARIS_THROW_EVALUATION_ERROR ( ast , \"bool value should be true or false\" ); } return bool_value ; } return boost :: none ; } boost :: any Functions :: constructEntity ( std :: shared_ptr < peg :: Ast > ast ) { auto pose_value = evaluate ( ast -> nodes [ 0 ] -> name , ast -> nodes [ 0 ]); geometry_msgs :: msg :: Pose pose ; if ( pose_value . type () == typeid ( types :: TypeBase < geometry_msgs :: msg :: Pose > )) { pose = boost :: any_cast < types :: TypeBase < geometry_msgs :: msg :: Pose >> ( pose_value ). getValue (); } else { POLARIS_THROW_EVALUATION_ERROR ( ast -> nodes [ 0 ], \"failed to parse pose\" ); } auto type_value = evaluate ( ast -> nodes [ 1 ] -> name , ast -> nodes [ 1 ]); std :: string type ; std :: vector < std :: string > types ; if ( type_value . type () == typeid ( types :: TypeBase < std :: string > )) { type = boost :: any_cast < types :: TypeBase < std :: string >> ( type_value ). getValue (); } else if ( type_value . type () == typeid ( types :: TypeBase < std :: vector < std :: string >> )) { types = boost :: any_cast < types :: TypeBase < std :: vector < std :: string >>> ( type_value ). getValue (); } else { POLARIS_THROW_EVALUATION_ERROR ( ast -> nodes [ 1 ], \"failed to parse types\" ); } auto polygon_value = evaluate ( ast -> nodes [ 2 ] -> name , ast -> nodes [ 2 ]); std :: vector < geometry_msgs :: msg :: Point > polygon ; if ( polygon_value . type () == typeid ( types :: TypeBase < std :: vector < geometry_msgs :: msg :: Point >> )) { polygon = boost :: any_cast < types :: TypeBase < std :: vector < geometry_msgs :: msg :: Point >>> ( polygon_value ). getValue (); } else { POLARIS_THROW_EVALUATION_ERROR ( ast -> nodes [ 2 ], \"failed to parse polygon\" ); } if ( types . size () == 0 ) { return types :: TypeBase < polaris :: types :: Entity > ( polaris :: types :: Entity ( pose , type , polygon )); } else { return types :: TypeBase < polaris :: types :: Entity > ( polaris :: types :: Entity ( pose , types , polygon )); } return boost :: none ; } boost :: any Functions :: constructArray ( std :: shared_ptr < peg :: Ast > ast ) { if ( ast -> nodes . size () == 0 ) { POLARIS_THROW_EVALUATION_ERROR ( ast , \"array is empty\" ); } const auto first_value = evaluate ( ast -> nodes [ 0 ] -> name , ast -> nodes [ 0 ]); const auto & value_type = first_value . type (); if ( value_type == typeid ( types :: TypeBase < int > )) { types :: TypeBase < std :: vector < int >> array ; std :: vector < int > array_value ; for ( const auto & node : ast -> nodes ) { auto value = evaluate ( node -> name , node ); if ( value . type () == typeid ( types :: TypeBase < int > )) { array_value . emplace_back ( boost :: any_cast < types :: TypeBase < int >> ( value ). getValue ()); } else { POLARIS_THROW_EVALUATION_ERROR ( ast , \"array value is not int\" ); } } array . setValue ( array_value ); return array ; } if ( value_type == typeid ( types :: TypeBase < double > )) { types :: TypeBase < std :: vector < double >> array ; std :: vector < double > array_value ; for ( const auto & node : ast -> nodes ) { auto value = evaluate ( node -> name , node ); if ( value . type () == typeid ( types :: TypeBase < double > )) { array_value . emplace_back ( boost :: any_cast < types :: TypeBase < double >> ( value ). getValue ()); } else { POLARIS_THROW_EVALUATION_ERROR ( ast , \"array value is not double\" ); } } array . setValue ( array_value ); return array ; } if ( value_type == typeid ( types :: TypeBase < std :: string > )) { types :: TypeBase < std :: vector < std :: string >> array ; std :: vector < std :: string > array_value ; for ( const auto & node : ast -> nodes ) { auto value = evaluate ( node -> name , node ); if ( value . type () == typeid ( types :: TypeBase < std :: string > )) { array_value . emplace_back ( boost :: any_cast < types :: TypeBase < std :: string >> ( value ). getValue ()); } else { POLARIS_THROW_EVALUATION_ERROR ( ast , \"array value is not string\" ); } } array . setValue ( array_value ); return array ; } if ( value_type == typeid ( types :: TypeBase < bool > )) { types :: TypeBase < std :: vector < bool >> array ; std :: vector < bool > array_value ; for ( const auto & node : ast -> nodes ) { auto value = evaluate ( node -> name , node ); if ( value . type () == typeid ( types :: TypeBase < bool > )) { array_value . emplace_back ( boost :: any_cast < types :: TypeBase < bool >> ( value ). getValue ()); } else { POLARIS_THROW_EVALUATION_ERROR ( ast , \"array value is not bool\" ); } } array . setValue ( array_value ); return array ; } if ( value_type == typeid ( types :: TypeBase < geometry_msgs :: msg :: Quaternion > )) { types :: TypeBase < std :: vector < geometry_msgs :: msg :: Quaternion >> array ; std :: vector < geometry_msgs :: msg :: Quaternion > array_value ; for ( const auto & node : ast -> nodes ) { auto value = evaluate ( node -> name , node ); if ( value . type () == typeid ( types :: TypeBase < geometry_msgs :: msg :: Quaternion > )) { array_value . emplace_back ( boost :: any_cast < types :: TypeBase < geometry_msgs :: msg :: Quaternion >> ( value ). getValue ()); } else { POLARIS_THROW_EVALUATION_ERROR ( ast , \"array value is not quaternion\" ); } } array . setValue ( array_value ); return array ; } if ( value_type == typeid ( types :: TypeBase < geometry_msgs :: msg :: Point > )) { types :: TypeBase < std :: vector < geometry_msgs :: msg :: Point >> array ; std :: vector < geometry_msgs :: msg :: Point > array_value ; for ( const auto & node : ast -> nodes ) { auto value = evaluate ( node -> name , node ); if ( value . type () == typeid ( types :: TypeBase < geometry_msgs :: msg :: Point > )) { array_value . emplace_back ( boost :: any_cast < types :: TypeBase < geometry_msgs :: msg :: Point >> ( value ). getValue ()); } else { POLARIS_THROW_EVALUATION_ERROR ( ast , \"array value is not point\" ); } } array . setValue ( array_value ); return array ; } if ( value_type == typeid ( types :: TypeBase < geometry_msgs :: msg :: Pose > )) { types :: TypeBase < std :: vector < geometry_msgs :: msg :: Pose >> array ; std :: vector < geometry_msgs :: msg :: Pose > array_value ; for ( const auto & node : ast -> nodes ) { auto value = evaluate ( node -> name , node ); if ( value . type () == typeid ( types :: TypeBase < geometry_msgs :: msg :: Pose > )) { array_value . emplace_back ( boost :: any_cast < types :: TypeBase < geometry_msgs :: msg :: Pose >> ( value ). getValue ()); } else { POLARIS_THROW_EVALUATION_ERROR ( ast , \"array value is not pose\" ); } } array . setValue ( array_value ); return array ; } if ( value_type == typeid ( types :: TypeBase < types :: Entity > )) { types :: TypeBase < std :: vector < types :: Entity >> array ; std :: vector < types :: Entity > array_value ; for ( const auto & node : ast -> nodes ) { auto value = evaluate ( node -> name , node ); if ( value . type () == typeid ( types :: TypeBase < types :: Entity > )) { array_value . emplace_back ( boost :: any_cast < types :: TypeBase < types :: Entity >> ( value ). getValue ()); } else { POLARIS_THROW_EVALUATION_ERROR ( ast , \"array value is not pose\" ); } } array . setValue ( array_value ); return array ; } return boost :: none ; } boost :: any Functions :: constructString ( std :: shared_ptr < peg :: Ast > ast ) { if ( ast -> name == \"STRING\" ) { types :: TypeBase < std :: string > str_value ; str_value . setValue ( ast -> token ); return str_value ; } return boost :: none ; } boost :: any Functions :: constructInteger ( std :: shared_ptr < peg :: Ast > ast ) { if ( ast -> name == \"INTEGER\" ) { try { types :: TypeBase < int > int_value ; int_value . setValue ( std :: stoi ( ast -> token )); return int_value ; } catch ( std :: invalid_argument ) { POLARIS_THROW_EVALUATION_ERROR ( ast , \"failed to parse token into int value, std::invalid_argument\" ); } catch ( std :: out_of_range ) { POLARIS_THROW_EVALUATION_ERROR ( ast , \"failed to parse token into int value, std::out_of_range\" ); } } return boost :: none ; } boost :: any Functions :: constructDouble ( std :: shared_ptr < peg :: Ast > ast ) { if ( ast -> name == \"DOUBLE\" || ast -> name == \"INTEGER\" ) { try { types :: TypeBase < double > double_value ; double_value . setValue ( std :: stod ( ast -> token )); return double_value ; } catch ( std :: invalid_argument ) { POLARIS_THROW_EVALUATION_ERROR ( ast , \"failed to parse token into double value, std::invalid_argument\" ); } catch ( std :: out_of_range ) { POLARIS_THROW_EVALUATION_ERROR ( ast , \"failed to parse token into double value, std::out_of_range\" ); } } return boost :: none ; } boost :: any Functions :: constructPose ( std :: shared_ptr < peg :: Ast > ast ) { geometry_msgs :: msg :: Pose pose ; if ( ast -> name == \"ARGUMENTS\" ) { if ( ast -> nodes [ 0 ] -> name == \"CALL\" ) { if ( ast -> nodes [ 0 ] -> nodes [ 0 ] -> name == \"IDENTIFIER\" ) { boost :: any val = evaluate ( ast -> nodes [ 0 ] -> nodes [ 0 ] -> token , ast -> nodes [ 0 ]); if ( ast -> nodes [ 0 ] -> nodes [ 0 ] -> token == \"point\" ) { if ( val . type () == typeid ( types :: TypeBase < geometry_msgs :: msg :: Point > )) { auto p = boost :: any_cast < types :: TypeBase < geometry_msgs :: msg :: Point >> ( val ). getValue (); pose . position = p ; } else { POLARIS_THROW_EVALUATION_ERROR ( ast , \"constracting point type failed\" ); } } else { POLARIS_THROW_EVALUATION_ERROR ( ast , \"first argument shold be point type\" ); } } } else if ( ast -> nodes [ 0 ] -> name == \"IDENTIFIER\" ) { if ( variables_ . count ( ast -> nodes [ 0 ] -> token ) == 0 ) { POLARIS_THROW_EVALUATION_ERROR ( ast , \"variable \" + ast -> nodes [ 0 ] -> token + \" did not difined.\" ); } if ( variables_ [ ast -> nodes [ 0 ] -> token ]. type () == typeid ( types :: TypeBase < geometry_msgs :: msg :: Point > )) { pose . position = boost :: any_cast < types :: TypeBase < geometry_msgs :: msg :: Point >> ( variables_ [ ast -> nodes [ 0 ] -> token ]). getValue (); } } else { POLARIS_THROW_EVALUATION_ERROR ( ast , \"name of the node is invalid\" ); } if ( ast -> nodes [ 1 ] -> name == \"CALL\" ) { if ( ast -> nodes [ 1 ] -> nodes [ 0 ] -> name == \"IDENTIFIER\" ) { boost :: any val = evaluate ( ast -> nodes [ 1 ] -> nodes [ 0 ] -> token , ast -> nodes [ 1 ]); if ( ast -> nodes [ 1 ] -> nodes [ 0 ] -> token == \"quaternion\" ) { if ( val . type () == typeid ( types :: TypeBase < geometry_msgs :: msg :: Quaternion > )) { auto q = boost :: any_cast < types :: TypeBase < geometry_msgs :: msg :: Quaternion >> ( val ). getValue (); pose . orientation = q ; } else { POLARIS_THROW_EVALUATION_ERROR ( ast , \"constracting quaternion type failed\" ); } } else { POLARIS_THROW_EVALUATION_ERROR ( ast , \"second argument shold be quaternion type\" ); } } } else if ( ast -> nodes [ 1 ] -> name == \"IDENTIFIER\" ) { if ( variables_ . count ( ast -> nodes [ 1 ] -> token ) == 0 ) { POLARIS_THROW_EVALUATION_ERROR ( ast , \"variable \" + ast -> nodes [ 1 ] -> token + \" did not difined.\" ); } if ( variables_ [ ast -> nodes [ 1 ] -> token ]. type () == typeid ( types :: TypeBase < geometry_msgs :: msg :: Quaternion > )) { pose . orientation = boost :: any_cast < types :: TypeBase < geometry_msgs :: msg :: Quaternion >> ( variables_ [ ast -> nodes [ 1 ] -> token ]). getValue (); } } else { POLARIS_THROW_EVALUATION_ERROR ( ast , \"name of the node is invalid\" ); } } types :: TypeBase < geometry_msgs :: msg :: Pose > pose_value ; pose_value . setValue ( pose ); return pose_value ; } boost :: any Functions :: constructPoint ( std :: shared_ptr < peg :: Ast > ast ) { geometry_msgs :: msg :: Point point ; if ( ast -> name == \"ARGUMENTS\" ) { try { if ( ast -> nodes [ 0 ] -> name == \"CALL\" ) { auto val = evaluate ( ast -> nodes [ 0 ] -> nodes [ 0 ] -> token , ast -> nodes [ 0 ] -> nodes [ 1 ]); if ( val . type () != typeid ( types :: TypeBase < double > )) { POLARIS_THROW_EVALUATION_ERROR ( ast , \"failed to interprit as double value\" ); } point . x = boost :: any_cast < types :: TypeBase < double >> ( val ). getValue (); } else if ( ast -> nodes [ 0 ] -> name == \"IDENTIFIER\" ) { point . x = boost :: any_cast < types :: TypeBase < double >> ( variables_ [ ast -> nodes [ 0 ] -> token ]). getValue (); } else { point . x = boost :: any_cast < types :: TypeBase < double >> ( constructDouble ( ast -> nodes [ 0 ])). getValue (); } if ( ast -> nodes [ 1 ] -> name == \"CALL\" ) { auto val = evaluate ( ast -> nodes [ 1 ] -> nodes [ 0 ] -> token , ast -> nodes [ 1 ] -> nodes [ 1 ]); if ( val . type () != typeid ( types :: TypeBase < double > )) { POLARIS_THROW_EVALUATION_ERROR ( ast , \"failed to interprit as double value\" ); } point . y = boost :: any_cast < types :: TypeBase < double >> ( val ). getValue (); } else if ( ast -> nodes [ 1 ] -> name == \"IDENTIFIER\" ) { point . y = boost :: any_cast < types :: TypeBase < double >> ( variables_ [ ast -> nodes [ 1 ] -> token ]). getValue (); } else { point . y = boost :: any_cast < types :: TypeBase < double >> ( constructDouble ( ast -> nodes [ 1 ])). getValue (); } if ( ast -> nodes [ 2 ] -> name == \"CALL\" ) { auto val = evaluate ( ast -> nodes [ 2 ] -> nodes [ 0 ] -> token , ast -> nodes [ 2 ] -> nodes [ 1 ]); if ( val . type () != typeid ( types :: TypeBase < double > )) { POLARIS_THROW_EVALUATION_ERROR ( ast , \"failed to interprit as double value\" ); } point . z = boost :: any_cast < types :: TypeBase < double >> ( val ). getValue (); } else if ( ast -> nodes [ 2 ] -> name == \"IDENTIFIER\" ) { point . z = boost :: any_cast < types :: TypeBase < double >> ( variables_ [ ast -> nodes [ 2 ] -> token ]). getValue (); } else { point . z = boost :: any_cast < types :: TypeBase < double >> ( constructDouble ( ast -> nodes [ 2 ])). getValue (); } types :: TypeBase < geometry_msgs :: msg :: Point > point_value ; point_value . setValue ( point ); return point_value ; } catch ( boost :: bad_any_cast ) { POLARIS_THROW_EVALUATION_ERROR ( ast , \"failed to cast as double value in constructing point, boost::bad_any_cast\" ); } } return boost :: none ; } boost :: any Functions :: constructQuaternionFromRpy ( std :: shared_ptr < peg :: Ast > ast ) { geometry_msgs :: msg :: Vector3 rpy ; if ( ast -> name == \"ARGUMENTS\" ) { try { if ( ast -> nodes [ 0 ] -> name == \"CALL\" ) { auto val = evaluate ( ast -> nodes [ 0 ] -> nodes [ 0 ] -> token , ast -> nodes [ 0 ] -> nodes [ 1 ]); if ( val . type () != typeid ( types :: TypeBase < double > )) { POLARIS_THROW_EVALUATION_ERROR ( ast , \"failed to interprit as double value\" ); } rpy . x = boost :: any_cast < types :: TypeBase < double >> ( val ). getValue (); } else if ( ast -> nodes [ 0 ] -> name == \"IDENTIFIER\" ) { rpy . x = boost :: any_cast < types :: TypeBase < double >> ( variables_ [ ast -> nodes [ 0 ] -> token ]). getValue (); } else { rpy . x = boost :: any_cast < types :: TypeBase < double >> ( constructDouble ( ast -> nodes [ 0 ])). getValue (); } if ( ast -> nodes [ 1 ] -> name == \"CALL\" ) { auto val = evaluate ( ast -> nodes [ 1 ] -> nodes [ 0 ] -> token , ast -> nodes [ 1 ] -> nodes [ 1 ]); if ( val . type () != typeid ( types :: TypeBase < double > )) { POLARIS_THROW_EVALUATION_ERROR ( ast , \"failed to interprit as double value\" ); } rpy . y = boost :: any_cast < types :: TypeBase < double >> ( val ). getValue (); } else if ( ast -> nodes [ 1 ] -> name == \"IDENTIFIER\" ) { rpy . y = boost :: any_cast < types :: TypeBase < double >> ( variables_ [ ast -> nodes [ 1 ] -> token ]). getValue (); } else { rpy . y = boost :: any_cast < types :: TypeBase < double >> ( constructDouble ( ast -> nodes [ 1 ])). getValue (); } if ( ast -> nodes [ 2 ] -> name == \"CALL\" ) { auto val = evaluate ( ast -> nodes [ 2 ] -> nodes [ 0 ] -> token , ast -> nodes [ 2 ] -> nodes [ 1 ]); if ( val . type () != typeid ( types :: TypeBase < double > )) { POLARIS_THROW_EVALUATION_ERROR ( ast , \"failed to interprit as double value\" ); } rpy . z = boost :: any_cast < types :: TypeBase < double >> ( val ). getValue (); } else if ( ast -> nodes [ 2 ] -> name == \"IDENTIFIER\" ) { rpy . z = boost :: any_cast < types :: TypeBase < double >> ( variables_ [ ast -> nodes [ 2 ] -> token ]). getValue (); } else { rpy . z = boost :: any_cast < types :: TypeBase < double >> ( constructDouble ( ast -> nodes [ 2 ])). getValue (); } types :: TypeBase < geometry_msgs :: msg :: Quaternion > quat_value ; geometry_msgs :: msg :: Quaternion quat = quaternion_operation :: convertEulerAngleToQuaternion ( rpy ); quat_value . setValue ( quat ); return quat_value ; } catch ( boost :: bad_any_cast ) { POLARIS_THROW_EVALUATION_ERROR ( ast , \"failed to cast as double value in constructing quaternion, boost::bad_any_cast\" ); } } return boost :: none ; } boost :: any Functions :: constructQuaternion ( std :: shared_ptr < peg :: Ast > ast ) { geometry_msgs :: msg :: Quaternion quat ; if ( ast -> name == \"ARGUMENTS\" ) { try { if ( ast -> nodes [ 0 ] -> name == \"CALL\" ) { auto val = evaluate ( ast -> nodes [ 0 ] -> nodes [ 0 ] -> token , ast -> nodes [ 0 ] -> nodes [ 1 ]); if ( val . type () != typeid ( types :: TypeBase < double > )) { POLARIS_THROW_EVALUATION_ERROR ( ast , \"failed to interprit as double value\" ); } quat . x = boost :: any_cast < types :: TypeBase < double >> ( val ). getValue (); } else if ( ast -> nodes [ 0 ] -> name == \"IDENTIFIER\" ) { quat . x = boost :: any_cast < types :: TypeBase < double >> ( variables_ [ ast -> nodes [ 0 ] -> token ]). getValue (); } else { quat . x = boost :: any_cast < types :: TypeBase < double >> ( constructDouble ( ast -> nodes [ 0 ])). getValue (); } if ( ast -> nodes [ 1 ] -> name == \"CALL\" ) { auto val = evaluate ( ast -> nodes [ 1 ] -> nodes [ 0 ] -> token , ast -> nodes [ 1 ] -> nodes [ 1 ]); if ( val . type () != typeid ( types :: TypeBase < double > )) { POLARIS_THROW_EVALUATION_ERROR ( ast , \"failed to interprit as double value\" ); } quat . y = boost :: any_cast < types :: TypeBase < double >> ( val ). getValue (); } else if ( ast -> nodes [ 1 ] -> name == \"IDENTIFIER\" ) { quat . y = boost :: any_cast < types :: TypeBase < double >> ( variables_ [ ast -> nodes [ 1 ] -> token ]). getValue (); } else { quat . y = boost :: any_cast < types :: TypeBase < double >> ( constructDouble ( ast -> nodes [ 1 ])). getValue (); } if ( ast -> nodes [ 2 ] -> name == \"CALL\" ) { auto val = evaluate ( ast -> nodes [ 2 ] -> nodes [ 0 ] -> token , ast -> nodes [ 2 ] -> nodes [ 1 ]); if ( val . type () != typeid ( types :: TypeBase < double > )) { POLARIS_THROW_EVALUATION_ERROR ( ast , \"failed to interprit as double value\" ); } quat . z = boost :: any_cast < types :: TypeBase < double >> ( val ). getValue (); } else if ( ast -> nodes [ 2 ] -> name == \"IDENTIFIER\" ) { quat . z = boost :: any_cast < types :: TypeBase < double >> ( variables_ [ ast -> nodes [ 2 ] -> token ]). getValue (); } else { quat . z = boost :: any_cast < types :: TypeBase < double >> ( constructDouble ( ast -> nodes [ 2 ])). getValue (); } if ( ast -> nodes [ 3 ] -> name == \"CALL\" ) { auto val = evaluate ( ast -> nodes [ 3 ] -> nodes [ 0 ] -> token , ast -> nodes [ 3 ] -> nodes [ 1 ]); if ( val . type () != typeid ( types :: TypeBase < double > )) { POLARIS_THROW_EVALUATION_ERROR ( ast , \"failed to interprit as double value\" ); } quat . w = boost :: any_cast < types :: TypeBase < double >> ( val ). getValue (); } else if ( ast -> nodes [ 3 ] -> name == \"IDENTIFIER\" ) { quat . w = boost :: any_cast < types :: TypeBase < double >> ( variables_ [ ast -> nodes [ 3 ] -> token ]). getValue (); } else { quat . w = boost :: any_cast < types :: TypeBase < double >> ( constructDouble ( ast -> nodes [ 3 ])). getValue (); } types :: TypeBase < geometry_msgs :: msg :: Quaternion > quat_value ; quat_value . setValue ( quat ); return quat_value ; } catch ( boost :: bad_any_cast ) { POLARIS_THROW_EVALUATION_ERROR ( ast , \"failed to cast as double value in constructing quaternion, boost::bad_any_cast\" ); } } return boost :: none ; } boost :: any Functions :: multiplication ( std :: shared_ptr < peg :: Ast > ast ) { auto v0 = evaluate ( ast -> nodes [ 0 ] -> name , ast -> nodes [ 0 ]); auto v1 = evaluate ( ast -> nodes [ 2 ] -> name , ast -> nodes [ 2 ]); // (quaternion value) * (quaternion value) if ( v0 . type () == typeid ( types :: TypeBase < geometry_msgs :: msg :: Quaternion > ) && v1 . type () == typeid ( types :: TypeBase < geometry_msgs :: msg :: Quaternion > )) { types :: TypeBase < geometry_msgs :: msg :: Quaternion > ret ; ret . setValue ( boost :: any_cast < types :: TypeBase < geometry_msgs :: msg :: Quaternion >> ( v0 ). getValue () * boost :: any_cast < types :: TypeBase < geometry_msgs :: msg :: Quaternion >> ( v1 ). getValue ()); return ret ; } // (double value) * (double value) if ( v0 . type () == typeid ( types :: TypeBase < double > ) && v1 . type () == typeid ( types :: TypeBase < double > )) { types :: TypeBase < double > ret ; ret . setValue ( boost :: any_cast < types :: TypeBase < double >> ( v0 ). getValue () * boost :: any_cast < types :: TypeBase < double >> ( v1 ). getValue ()); return ret ; } // (int value) * (double value) if ( v0 . type () == typeid ( types :: TypeBase < int > ) && v1 . type () == typeid ( types :: TypeBase < double > )) { types :: TypeBase < double > ret ; ret . setValue ( boost :: any_cast < types :: TypeBase < int >> ( v0 ). getValue () * boost :: any_cast < types :: TypeBase < double >> ( v1 ). getValue ()); return ret ; } // (double value) * (int value) if ( v0 . type () == typeid ( types :: TypeBase < double > ) && v1 . type () == typeid ( types :: TypeBase < int > )) { types :: TypeBase < double > ret ; ret . setValue ( boost :: any_cast < types :: TypeBase < double >> ( v0 ). getValue () * boost :: any_cast < types :: TypeBase < int >> ( v1 ). getValue ()); return ret ; } // (int value) * (int value) if ( v0 . type () == typeid ( types :: TypeBase < int > ) && v1 . type () == typeid ( types :: TypeBase < int > )) { types :: TypeBase < int > ret ; ret . setValue ( boost :: any_cast < types :: TypeBase < int >> ( v0 ). getValue () * boost :: any_cast < types :: TypeBase < int >> ( v1 ). getValue ()); return ret ; } POLARIS_THROW_EVALUATION_ERROR ( ast , \"multiplication operators did not defined yet.\" ); } boost :: any Functions :: division ( std :: shared_ptr < peg :: Ast > ast ) { auto v0 = evaluate ( ast -> nodes [ 0 ] -> name , ast -> nodes [ 0 ]); auto v1 = evaluate ( ast -> nodes [ 2 ] -> name , ast -> nodes [ 2 ]); // (double value) * (double value) if ( v0 . type () == typeid ( types :: TypeBase < double > ) && v1 . type () == typeid ( types :: TypeBase < double > )) { types :: TypeBase < double > ret ; ret . setValue ( boost :: any_cast < types :: TypeBase < double >> ( v0 ). getValue () / boost :: any_cast < types :: TypeBase < double >> ( v1 ). getValue ()); return ret ; } // (int value) * (double value) if ( v0 . type () == typeid ( types :: TypeBase < int > ) && v1 . type () == typeid ( types :: TypeBase < double > )) { types :: TypeBase < double > ret ; ret . setValue ( boost :: any_cast < types :: TypeBase < int >> ( v0 ). getValue () / boost :: any_cast < types :: TypeBase < double >> ( v1 ). getValue ()); return ret ; } // (double value) * (int value) if ( v0 . type () == typeid ( types :: TypeBase < double > ) && v1 . type () == typeid ( types :: TypeBase < int > )) { types :: TypeBase < double > ret ; ret . setValue ( boost :: any_cast < types :: TypeBase < double >> ( v0 ). getValue () / boost :: any_cast < types :: TypeBase < int >> ( v1 ). getValue ()); return ret ; } // (int value) * (int value) if ( v0 . type () == typeid ( types :: TypeBase < int > ) && v1 . type () == typeid ( types :: TypeBase < int > )) { types :: TypeBase < int > ret ; ret . setValue ( boost :: any_cast < types :: TypeBase < int >> ( v0 ). getValue () / boost :: any_cast < types :: TypeBase < int >> ( v1 ). getValue ()); return ret ; } POLARIS_THROW_EVALUATION_ERROR ( ast , \"division operators did not defined yet.\" ); } boost :: any Functions :: subtraction ( std :: shared_ptr < peg :: Ast > ast ) { auto v0 = evaluate ( ast -> nodes [ 0 ] -> name , ast -> nodes [ 0 ]); auto v1 = evaluate ( ast -> nodes [ 2 ] -> name , ast -> nodes [ 2 ]); // (double value) - (double value) if ( v0 . type () == typeid ( types :: TypeBase < double > ) && v1 . type () == typeid ( types :: TypeBase < double > )) { types :: TypeBase < double > ret ; ret . setValue ( boost :: any_cast < types :: TypeBase < double >> ( v0 ). getValue () - boost :: any_cast < types :: TypeBase < double >> ( v1 ). getValue ()); return ret ; } // (int value) - (double value) if ( v0 . type () == typeid ( types :: TypeBase < int > ) && v1 . type () == typeid ( types :: TypeBase < double > )) { types :: TypeBase < double > ret ; ret . setValue ( static_cast < double > ( boost :: any_cast < types :: TypeBase < int >> ( v0 ). getValue ()) - boost :: any_cast < types :: TypeBase < double >> ( v1 ). getValue ()); return ret ; } // (double value) - (int value) if ( v0 . type () == typeid ( types :: TypeBase < double > ) && v1 . type () == typeid ( types :: TypeBase < int > )) { types :: TypeBase < double > ret ; ret . setValue ( boost :: any_cast < types :: TypeBase < double >> ( v0 ). getValue () - static_cast < double > ( boost :: any_cast < types :: TypeBase < int >> ( v1 ). getValue ())); return ret ; } // (int value) - (int value) if ( v0 . type () == typeid ( types :: TypeBase < double > ) && v1 . type () == typeid ( types :: TypeBase < int > )) { types :: TypeBase < int > ret ; ret . setValue ( boost :: any_cast < types :: TypeBase < int >> ( v0 ). getValue () - boost :: any_cast < types :: TypeBase < int >> ( v1 ). getValue ()); return ret ; } POLARIS_THROW_EVALUATION_ERROR ( ast , \"subcraction operators did not defined yet.\" ); } boost :: any Functions :: addition ( std :: shared_ptr < peg :: Ast > ast ) { auto v0 = evaluate ( ast -> nodes [ 0 ] -> name , ast -> nodes [ 0 ]); auto v1 = evaluate ( ast -> nodes [ 2 ] -> name , ast -> nodes [ 2 ]); // (double value) + (double value) if ( v0 . type () == typeid ( types :: TypeBase < double > ) && v1 . type () == typeid ( types :: TypeBase < double > )) { types :: TypeBase < double > ret ; ret . setValue ( boost :: any_cast < types :: TypeBase < double >> ( v0 ). getValue () + boost :: any_cast < types :: TypeBase < double >> ( v1 ). getValue ()); return ret ; } // (int value) + (double value) if ( v0 . type () == typeid ( types :: TypeBase < int > ) && v1 . type () == typeid ( types :: TypeBase < double > )) { types :: TypeBase < double > ret ; ret . setValue ( static_cast < double > ( boost :: any_cast < types :: TypeBase < int >> ( v0 ). getValue ()) + boost :: any_cast < types :: TypeBase < double >> ( v1 ). getValue ()); return ret ; } // (double value) + (int value) if ( v0 . type () == typeid ( types :: TypeBase < double > ) && v1 . type () == typeid ( types :: TypeBase < int > )) { types :: TypeBase < double > ret ; ret . setValue ( boost :: any_cast < types :: TypeBase < double >> ( v0 ). getValue () + static_cast < double > ( boost :: any_cast < types :: TypeBase < int >> ( v1 ). getValue ())); return ret ; } // (int value) + (int value) if ( v0 . type () == typeid ( types :: TypeBase < double > ) && v1 . type () == typeid ( types :: TypeBase < int > )) { types :: TypeBase < int > ret ; ret . setValue ( boost :: any_cast < types :: TypeBase < int >> ( v0 ). getValue () + boost :: any_cast < types :: TypeBase < int >> ( v1 ). getValue ()); return ret ; } POLARIS_THROW_EVALUATION_ERROR ( ast , \"addition operators did not defined yet.\" ); } } // namespace built_in_functions } // namespace polaris Updated on 26 December 2020 at 00:59:10 UTC","title":"Source code"},{"location":"doxygen/markdown/Files/functions_8hpp/","text":"/home/runner/work/polaris/polaris/include/polaris/built_in_functions/functions.hpp # Namespaces # Name polaris::built_in_functions polaris Classes # Name class polaris::built_in_functions::Functions Source code # // Copyright (c) 2020, OUXT-Polaris // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef POLARIS__BUILT_IN_FUNCTIONS__FUNCTIONS_HPP_ #define POLARIS__BUILT_IN_FUNCTIONS__FUNCTIONS_HPP_ #include <polaris/exception.hpp> #include <polaris/types/type_base.hpp> #include <polaris/types/entity.hpp> #include <peglib.h> #include <geometry_msgs/msg/pose.hpp> #include <geometry_msgs/msg/quaternion.hpp> #include <boost/optional.hpp> #include <boost/any.hpp> #include <functional> #include <unordered_map> #include <memory> #include <string> #include <utility> namespace polaris { namespace built_in_functions { class Functions { public : Functions () { functions_ . insert ( std :: make_pair ( \"integer\" , std :: bind ( & Functions :: constructInteger , this , std :: placeholders :: _1 ))); functions_ . insert ( std :: make_pair ( \"INTEGER\" , std :: bind ( & Functions :: constructInteger , this , std :: placeholders :: _1 ))); functions_ . insert ( std :: make_pair ( \"double\" , std :: bind ( & Functions :: constructDouble , this , std :: placeholders :: _1 ))); functions_ . insert ( std :: make_pair ( \"DOUBLE\" , std :: bind ( & Functions :: constructDouble , this , std :: placeholders :: _1 ))); functions_ . insert ( std :: make_pair ( \"string\" , std :: bind ( & Functions :: constructString , this , std :: placeholders :: _1 ))); functions_ . insert ( std :: make_pair ( \"bool\" , std :: bind ( & Functions :: constructBoolean , this , std :: placeholders :: _1 ))); functions_ . insert ( std :: make_pair ( \"boolean\" , std :: bind ( & Functions :: constructBoolean , this , std :: placeholders :: _1 ))); functions_ . insert ( std :: make_pair ( \"BOOLEAN\" , std :: bind ( & Functions :: constructBoolean , this , std :: placeholders :: _1 ))); functions_ . insert ( std :: make_pair ( \"STRING\" , std :: bind ( & Functions :: constructString , this , std :: placeholders :: _1 ))); functions_ . insert ( std :: make_pair ( \"array\" , std :: bind ( & Functions :: constructArray , this , std :: placeholders :: _1 ))); functions_ . insert ( std :: make_pair ( \"ARRAY\" , std :: bind ( & Functions :: constructArray , this , std :: placeholders :: _1 ))); functions_ . insert ( std :: make_pair ( \"quaternion\" , std :: bind ( & Functions :: constructQuaternion , this , std :: placeholders :: _1 ))); functions_ . insert ( std :: make_pair ( \"rpy\" , std :: bind ( & Functions :: constructQuaternionFromRpy , this , std :: placeholders :: _1 ))); functions_ . insert ( std :: make_pair ( \"point\" , std :: bind ( & Functions :: constructPoint , this , std :: placeholders :: _1 ))); functions_ . insert ( std :: make_pair ( \"pose\" , std :: bind ( & Functions :: constructPose , this , std :: placeholders :: _1 ))); functions_ . insert ( std :: make_pair ( \"entity\" , std :: bind ( & Functions :: constructEntity , this , std :: placeholders :: _1 ))); functions_ . insert ( std :: make_pair ( \"+\" , std :: bind ( & Functions :: addition , this , std :: placeholders :: _1 ))); functions_ . insert ( std :: make_pair ( \"-\" , std :: bind ( & Functions :: subtraction , this , std :: placeholders :: _1 ))); functions_ . insert ( std :: make_pair ( \"*\" , std :: bind ( & Functions :: multiplication , this , std :: placeholders :: _1 ))); functions_ . insert ( std :: make_pair ( \"/\" , std :: bind ( & Functions :: division , this , std :: placeholders :: _1 ))); functions_ . insert ( std :: make_pair ( \"IDENTIFIER\" , std :: bind ( & Functions :: fetchVariable , this , std :: placeholders :: _1 ))); } boost :: any evaluate ( std :: string function , std :: shared_ptr < peg :: Ast > ast ) { if ( ast -> name == \"PREFIX_EXPR\" ) { if ( ast -> nodes [ 0 ] -> token == \"-\" ) { auto ret = evaluate ( ast -> nodes [ 1 ] -> name , ast -> nodes [ 1 ]); if ( ret . type () == typeid ( boost :: none )) { return boost :: none ; } if ( ret . type () == typeid ( types :: TypeBase < double > )) { types :: TypeBase < double > double_value = boost :: any_cast < types :: TypeBase < double >> ( ret ); double_value . setValue ( -1 * double_value . getValue ()); return double_value ; } if ( ret . type () == typeid ( types :: TypeBase < int > )) { types :: TypeBase < int > int_value = boost :: any_cast < types :: TypeBase < int >> ( ret ); int_value . setValue ( -1 * int_value . getValue ()); return int_value ; } } } if ( ast -> name == \"CALL\" ) { auto ret = evaluate ( ast -> nodes [ 0 ] -> token , ast -> nodes [ 1 ]); if ( ret . type () == typeid ( boost :: none )) { if ( variables_ . count ( ast -> nodes [ 0 ] -> token ) != 0 ) { return variables_ [ ast -> nodes [ 0 ] -> token ]; } return boost :: none ; } return ret ; } if ( functions_ . count ( function ) == 0 ) { POLARIS_THROW_EVALUATION_ERROR ( ast , \"function did not defined yet.\" ); } return functions_ [ function ]( ast ); } void setVariables ( std :: unordered_map < std :: string , boost :: any > variables ) { variables_ = variables ; } private : std :: unordered_map < std :: string , boost :: any > variables_ ; std :: unordered_map < std :: string , std :: function < boost :: any ( std :: shared_ptr < peg :: Ast > ast ) >> functions_ ; boost :: any constructBoolean ( std :: shared_ptr < peg :: Ast > ast ); boost :: any constructString ( std :: shared_ptr < peg :: Ast > ast ); boost :: any constructInteger ( std :: shared_ptr < peg :: Ast > ast ); boost :: any constructDouble ( std :: shared_ptr < peg :: Ast > ast ); boost :: any constructQuaternion ( std :: shared_ptr < peg :: Ast > ast ); boost :: any constructQuaternionFromRpy ( std :: shared_ptr < peg :: Ast > ast ); boost :: any constructPoint ( std :: shared_ptr < peg :: Ast > ast ); boost :: any constructPose ( std :: shared_ptr < peg :: Ast > ast ); boost :: any constructArray ( std :: shared_ptr < peg :: Ast > ast ); boost :: any constructEntity ( std :: shared_ptr < peg :: Ast > ast ); boost :: any addition ( std :: shared_ptr < peg :: Ast > ast ); boost :: any subtraction ( std :: shared_ptr < peg :: Ast > ast ); boost :: any multiplication ( std :: shared_ptr < peg :: Ast > ast ); boost :: any division ( std :: shared_ptr < peg :: Ast > ast ); boost :: any fetchVariable ( std :: shared_ptr < peg :: Ast > ast ); }; } // namespace built_in_functions } // namespace polaris #endif // POLARIS__BUILT_IN_FUNCTIONS__FUNCTIONS_HPP_ Updated on 26 December 2020 at 00:59:10 UTC","title":"/home/runner/work/polaris/polaris/include/polaris/built_in_functions/functions.hpp"},{"location":"doxygen/markdown/Files/functions_8hpp/#homerunnerworkpolarispolarisincludepolarisbuilt_in_functionsfunctionshpp","text":"","title":"/home/runner/work/polaris/polaris/include/polaris/built_in_functions/functions.hpp"},{"location":"doxygen/markdown/Files/functions_8hpp/#namespaces","text":"Name polaris::built_in_functions polaris","title":"Namespaces"},{"location":"doxygen/markdown/Files/functions_8hpp/#classes","text":"Name class polaris::built_in_functions::Functions","title":"Classes"},{"location":"doxygen/markdown/Files/functions_8hpp/#source-code","text":"// Copyright (c) 2020, OUXT-Polaris // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef POLARIS__BUILT_IN_FUNCTIONS__FUNCTIONS_HPP_ #define POLARIS__BUILT_IN_FUNCTIONS__FUNCTIONS_HPP_ #include <polaris/exception.hpp> #include <polaris/types/type_base.hpp> #include <polaris/types/entity.hpp> #include <peglib.h> #include <geometry_msgs/msg/pose.hpp> #include <geometry_msgs/msg/quaternion.hpp> #include <boost/optional.hpp> #include <boost/any.hpp> #include <functional> #include <unordered_map> #include <memory> #include <string> #include <utility> namespace polaris { namespace built_in_functions { class Functions { public : Functions () { functions_ . insert ( std :: make_pair ( \"integer\" , std :: bind ( & Functions :: constructInteger , this , std :: placeholders :: _1 ))); functions_ . insert ( std :: make_pair ( \"INTEGER\" , std :: bind ( & Functions :: constructInteger , this , std :: placeholders :: _1 ))); functions_ . insert ( std :: make_pair ( \"double\" , std :: bind ( & Functions :: constructDouble , this , std :: placeholders :: _1 ))); functions_ . insert ( std :: make_pair ( \"DOUBLE\" , std :: bind ( & Functions :: constructDouble , this , std :: placeholders :: _1 ))); functions_ . insert ( std :: make_pair ( \"string\" , std :: bind ( & Functions :: constructString , this , std :: placeholders :: _1 ))); functions_ . insert ( std :: make_pair ( \"bool\" , std :: bind ( & Functions :: constructBoolean , this , std :: placeholders :: _1 ))); functions_ . insert ( std :: make_pair ( \"boolean\" , std :: bind ( & Functions :: constructBoolean , this , std :: placeholders :: _1 ))); functions_ . insert ( std :: make_pair ( \"BOOLEAN\" , std :: bind ( & Functions :: constructBoolean , this , std :: placeholders :: _1 ))); functions_ . insert ( std :: make_pair ( \"STRING\" , std :: bind ( & Functions :: constructString , this , std :: placeholders :: _1 ))); functions_ . insert ( std :: make_pair ( \"array\" , std :: bind ( & Functions :: constructArray , this , std :: placeholders :: _1 ))); functions_ . insert ( std :: make_pair ( \"ARRAY\" , std :: bind ( & Functions :: constructArray , this , std :: placeholders :: _1 ))); functions_ . insert ( std :: make_pair ( \"quaternion\" , std :: bind ( & Functions :: constructQuaternion , this , std :: placeholders :: _1 ))); functions_ . insert ( std :: make_pair ( \"rpy\" , std :: bind ( & Functions :: constructQuaternionFromRpy , this , std :: placeholders :: _1 ))); functions_ . insert ( std :: make_pair ( \"point\" , std :: bind ( & Functions :: constructPoint , this , std :: placeholders :: _1 ))); functions_ . insert ( std :: make_pair ( \"pose\" , std :: bind ( & Functions :: constructPose , this , std :: placeholders :: _1 ))); functions_ . insert ( std :: make_pair ( \"entity\" , std :: bind ( & Functions :: constructEntity , this , std :: placeholders :: _1 ))); functions_ . insert ( std :: make_pair ( \"+\" , std :: bind ( & Functions :: addition , this , std :: placeholders :: _1 ))); functions_ . insert ( std :: make_pair ( \"-\" , std :: bind ( & Functions :: subtraction , this , std :: placeholders :: _1 ))); functions_ . insert ( std :: make_pair ( \"*\" , std :: bind ( & Functions :: multiplication , this , std :: placeholders :: _1 ))); functions_ . insert ( std :: make_pair ( \"/\" , std :: bind ( & Functions :: division , this , std :: placeholders :: _1 ))); functions_ . insert ( std :: make_pair ( \"IDENTIFIER\" , std :: bind ( & Functions :: fetchVariable , this , std :: placeholders :: _1 ))); } boost :: any evaluate ( std :: string function , std :: shared_ptr < peg :: Ast > ast ) { if ( ast -> name == \"PREFIX_EXPR\" ) { if ( ast -> nodes [ 0 ] -> token == \"-\" ) { auto ret = evaluate ( ast -> nodes [ 1 ] -> name , ast -> nodes [ 1 ]); if ( ret . type () == typeid ( boost :: none )) { return boost :: none ; } if ( ret . type () == typeid ( types :: TypeBase < double > )) { types :: TypeBase < double > double_value = boost :: any_cast < types :: TypeBase < double >> ( ret ); double_value . setValue ( -1 * double_value . getValue ()); return double_value ; } if ( ret . type () == typeid ( types :: TypeBase < int > )) { types :: TypeBase < int > int_value = boost :: any_cast < types :: TypeBase < int >> ( ret ); int_value . setValue ( -1 * int_value . getValue ()); return int_value ; } } } if ( ast -> name == \"CALL\" ) { auto ret = evaluate ( ast -> nodes [ 0 ] -> token , ast -> nodes [ 1 ]); if ( ret . type () == typeid ( boost :: none )) { if ( variables_ . count ( ast -> nodes [ 0 ] -> token ) != 0 ) { return variables_ [ ast -> nodes [ 0 ] -> token ]; } return boost :: none ; } return ret ; } if ( functions_ . count ( function ) == 0 ) { POLARIS_THROW_EVALUATION_ERROR ( ast , \"function did not defined yet.\" ); } return functions_ [ function ]( ast ); } void setVariables ( std :: unordered_map < std :: string , boost :: any > variables ) { variables_ = variables ; } private : std :: unordered_map < std :: string , boost :: any > variables_ ; std :: unordered_map < std :: string , std :: function < boost :: any ( std :: shared_ptr < peg :: Ast > ast ) >> functions_ ; boost :: any constructBoolean ( std :: shared_ptr < peg :: Ast > ast ); boost :: any constructString ( std :: shared_ptr < peg :: Ast > ast ); boost :: any constructInteger ( std :: shared_ptr < peg :: Ast > ast ); boost :: any constructDouble ( std :: shared_ptr < peg :: Ast > ast ); boost :: any constructQuaternion ( std :: shared_ptr < peg :: Ast > ast ); boost :: any constructQuaternionFromRpy ( std :: shared_ptr < peg :: Ast > ast ); boost :: any constructPoint ( std :: shared_ptr < peg :: Ast > ast ); boost :: any constructPose ( std :: shared_ptr < peg :: Ast > ast ); boost :: any constructArray ( std :: shared_ptr < peg :: Ast > ast ); boost :: any constructEntity ( std :: shared_ptr < peg :: Ast > ast ); boost :: any addition ( std :: shared_ptr < peg :: Ast > ast ); boost :: any subtraction ( std :: shared_ptr < peg :: Ast > ast ); boost :: any multiplication ( std :: shared_ptr < peg :: Ast > ast ); boost :: any division ( std :: shared_ptr < peg :: Ast > ast ); boost :: any fetchVariable ( std :: shared_ptr < peg :: Ast > ast ); }; } // namespace built_in_functions } // namespace polaris #endif // POLARIS__BUILT_IN_FUNCTIONS__FUNCTIONS_HPP_ Updated on 26 December 2020 at 00:59:10 UTC","title":"Source code"},{"location":"doxygen/markdown/Files/grammar_8hpp/","text":"/home/runner/work/polaris/polaris/include/polaris/grammar/grammar.hpp # Source code # // Copyright (c) 2020, OUXT-Polaris // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef POLARIS__GRAMMAR__GRAMMAR_HPP_ #define POLARIS__GRAMMAR__GRAMMAR_HPP_ #include <string> namespace polaris { const char grammar [] = R \" ( PROGRAM <- STATEMENTS STATEMENTS <- (STATEMENT ';')* STATEMENT <- ASSIGNMENT / RETURN / EXPRESSION ASSIGNMENT <- 'let' IDENTIFIER '=' EXPRESSION RETURN <- 'return' EXPRESSION EXPRESSION <- INFIX_EXPR(PREFIX_EXPR, INFIX_OPE) INFIX_EXPR(ATOM, OPE) <- ATOM (OPE ATOM)* { precedence L == != L < > L + - L * / } IF <- 'if' '(' EXPRESSION ')' BLOCK ('else' BLOCK)? FUNCTION <- 'fn' '(' PARAMETERS ')' BLOCK PARAMETERS <- LIST(IDENTIFIER, ',') BLOCK <- '{' STATEMENTS '}' CALL <- PRIMARY (ARGUMENTS / INDEX)* ARGUMENTS <- '(' LIST(EXPRESSION, ',') ')' INDEX <- '[' EXPRESSION ']' PREFIX_EXPR <- PREFIX_OPE* CALL PRIMARY <- IF / FUNCTION / ARRAY / DOUBLE / INTEGER / BOOLEAN / NULL / IDENTIFIER / STRING / '(' EXPRESSION ')' ARRAY <- '[' LIST(EXPRESSION, ',') ']' IDENTIFIER <- !KEYWORD < [a-zA-Z]+ > INTEGER <- < '-'? [0-9]+ > DOUBLE <- < '-'? [0-9]+ '.' [0-9] > STRING <- < [\"] < (![\"] .)* > [\"] > BOOLEAN <- < 'true' / 'false' > NULL <- 'null' PREFIX_OPE <- < [-!] > INFIX_OPE <- < [-+/*<>] / '==' / '!=' > KEYWORD <- 'null' | 'true' | 'false' | 'let' | 'return' | 'if' | 'else' | 'fn' LIST(ITEM, DELM) <- (ITEM (~DELM ITEM)*)? LINE_COMMENT <- '//' (!LINE_END .)* &LINE_END LINE_END <- '\\r\\n' / '\\r' / '\\n' / !. %whitespace <- ([ \\t\\r\\n]+ / LINE_COMMENT)* ) \" ; } // namespace polaris #endif // POLARIS__GRAMMAR__GRAMMAR_HPP_ Updated on 26 December 2020 at 00:59:10 UTC","title":"/home/runner/work/polaris/polaris/include/polaris/grammar/grammar.hpp"},{"location":"doxygen/markdown/Files/grammar_8hpp/#homerunnerworkpolarispolarisincludepolarisgrammargrammarhpp","text":"","title":"/home/runner/work/polaris/polaris/include/polaris/grammar/grammar.hpp"},{"location":"doxygen/markdown/Files/grammar_8hpp/#source-code","text":"// Copyright (c) 2020, OUXT-Polaris // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef POLARIS__GRAMMAR__GRAMMAR_HPP_ #define POLARIS__GRAMMAR__GRAMMAR_HPP_ #include <string> namespace polaris { const char grammar [] = R \" ( PROGRAM <- STATEMENTS STATEMENTS <- (STATEMENT ';')* STATEMENT <- ASSIGNMENT / RETURN / EXPRESSION ASSIGNMENT <- 'let' IDENTIFIER '=' EXPRESSION RETURN <- 'return' EXPRESSION EXPRESSION <- INFIX_EXPR(PREFIX_EXPR, INFIX_OPE) INFIX_EXPR(ATOM, OPE) <- ATOM (OPE ATOM)* { precedence L == != L < > L + - L * / } IF <- 'if' '(' EXPRESSION ')' BLOCK ('else' BLOCK)? FUNCTION <- 'fn' '(' PARAMETERS ')' BLOCK PARAMETERS <- LIST(IDENTIFIER, ',') BLOCK <- '{' STATEMENTS '}' CALL <- PRIMARY (ARGUMENTS / INDEX)* ARGUMENTS <- '(' LIST(EXPRESSION, ',') ')' INDEX <- '[' EXPRESSION ']' PREFIX_EXPR <- PREFIX_OPE* CALL PRIMARY <- IF / FUNCTION / ARRAY / DOUBLE / INTEGER / BOOLEAN / NULL / IDENTIFIER / STRING / '(' EXPRESSION ')' ARRAY <- '[' LIST(EXPRESSION, ',') ']' IDENTIFIER <- !KEYWORD < [a-zA-Z]+ > INTEGER <- < '-'? [0-9]+ > DOUBLE <- < '-'? [0-9]+ '.' [0-9] > STRING <- < [\"] < (![\"] .)* > [\"] > BOOLEAN <- < 'true' / 'false' > NULL <- 'null' PREFIX_OPE <- < [-!] > INFIX_OPE <- < [-+/*<>] / '==' / '!=' > KEYWORD <- 'null' | 'true' | 'false' | 'let' | 'return' | 'if' | 'else' | 'fn' LIST(ITEM, DELM) <- (ITEM (~DELM ITEM)*)? LINE_COMMENT <- '//' (!LINE_END .)* &LINE_END LINE_END <- '\\r\\n' / '\\r' / '\\n' / !. %whitespace <- ([ \\t\\r\\n]+ / LINE_COMMENT)* ) \" ; } // namespace polaris #endif // POLARIS__GRAMMAR__GRAMMAR_HPP_ Updated on 26 December 2020 at 00:59:10 UTC","title":"Source code"},{"location":"doxygen/markdown/Files/parser_8cpp/","text":"/home/runner/work/polaris/polaris/src/parser/parser.cpp # Namespaces # Name polaris Source code # // Copyright (c) 2020, OUXT-Polaris // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #include <polaris/exception.hpp> #include <polaris/grammar/grammar.hpp> #include <polaris/built_in_functions/functions.hpp> #include <polaris/types/type_base.hpp> #include <polaris/parser/parser.hpp> #include <boost/optional.hpp> #include <memory> #include <string> #include <vector> #include <iostream> namespace polaris { Parser :: Parser ( bool verbose ) { verbose_ = verbose ; std :: string grammar = polaris :: grammar ; parser_ptr_ = std :: make_unique < peg :: parser > ( grammar . c_str ()); parser_ptr_ -> enable_ast (); } bool Parser :: evaluate ( std :: string line ) { variables_ . clear (); std :: shared_ptr < peg :: Ast > ast_ptr ; auto ret = parser_ptr_ -> parse ( line . c_str (), ast_ptr ); if ( ! ret ) { return false ; } ast_ptr = peg :: AstOptimizer ( true ). optimize ( ast_ptr ); evaluate ( ast_ptr ); return true ; } boost :: any Parser :: evaluate ( std :: shared_ptr < peg :: Ast > ast ) { if ( verbose_ ) { std :: cout << peg :: ast_to_s ( ast ) << std :: endl ; } if ( ast -> name == \"STATEMENTS\" ) { for ( size_t i = 0 ; i < ast -> nodes . size (); i ++ ) { evaluate ( ast -> nodes [ i ]); functions_ . setVariables ( variables_ ); } } if ( ast -> nodes . size () >= 3 ) { if ( ast -> nodes [ 1 ] -> name == \"INFIX_OPE\" ) { return functions_ . evaluate ( ast -> nodes [ 1 ] -> token , ast ); } } if ( ast -> name == \"ASSIGNMENT\" ) { auto symbol = ast -> nodes [ 0 ] -> token ; auto value = evaluate ( ast -> nodes [ 1 ]); variables_ [ symbol ] = value ; return value ; } if ( ast -> name == \"DOUBLE\" ) { return functions_ . evaluate ( \"double\" , ast ); } if ( ast -> name == \"INTEGER\" ) { return functions_ . evaluate ( \"integer\" , ast ); } if ( ast -> name == \"STRING\" ) { return functions_ . evaluate ( \"string\" , ast ); } if ( ast -> name == \"BOOLEAN\" ) { return functions_ . evaluate ( \"bool\" , ast ); } if ( ast -> name == \"ARRAY\" ) { return functions_ . evaluate ( \"array\" , ast ); } if ( ast -> name == \"CALL\" ) { auto ret = functions_ . evaluate ( ast -> nodes [ 0 ] -> token , ast -> nodes [ 1 ]); if ( ret . type () == typeid ( boost :: none )) { if ( variables_ . count ( ast -> nodes [ 0 ] -> token ) != 0 ) { return variables_ [ ast -> nodes [ 0 ] -> token ]; } return boost :: none ; } return ret ; } return boost :: none ; } } // namespace polaris Updated on 26 December 2020 at 00:59:10 UTC","title":"/home/runner/work/polaris/polaris/src/parser/parser.cpp"},{"location":"doxygen/markdown/Files/parser_8cpp/#homerunnerworkpolarispolarissrcparserparsercpp","text":"","title":"/home/runner/work/polaris/polaris/src/parser/parser.cpp"},{"location":"doxygen/markdown/Files/parser_8cpp/#namespaces","text":"Name polaris","title":"Namespaces"},{"location":"doxygen/markdown/Files/parser_8cpp/#source-code","text":"// Copyright (c) 2020, OUXT-Polaris // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #include <polaris/exception.hpp> #include <polaris/grammar/grammar.hpp> #include <polaris/built_in_functions/functions.hpp> #include <polaris/types/type_base.hpp> #include <polaris/parser/parser.hpp> #include <boost/optional.hpp> #include <memory> #include <string> #include <vector> #include <iostream> namespace polaris { Parser :: Parser ( bool verbose ) { verbose_ = verbose ; std :: string grammar = polaris :: grammar ; parser_ptr_ = std :: make_unique < peg :: parser > ( grammar . c_str ()); parser_ptr_ -> enable_ast (); } bool Parser :: evaluate ( std :: string line ) { variables_ . clear (); std :: shared_ptr < peg :: Ast > ast_ptr ; auto ret = parser_ptr_ -> parse ( line . c_str (), ast_ptr ); if ( ! ret ) { return false ; } ast_ptr = peg :: AstOptimizer ( true ). optimize ( ast_ptr ); evaluate ( ast_ptr ); return true ; } boost :: any Parser :: evaluate ( std :: shared_ptr < peg :: Ast > ast ) { if ( verbose_ ) { std :: cout << peg :: ast_to_s ( ast ) << std :: endl ; } if ( ast -> name == \"STATEMENTS\" ) { for ( size_t i = 0 ; i < ast -> nodes . size (); i ++ ) { evaluate ( ast -> nodes [ i ]); functions_ . setVariables ( variables_ ); } } if ( ast -> nodes . size () >= 3 ) { if ( ast -> nodes [ 1 ] -> name == \"INFIX_OPE\" ) { return functions_ . evaluate ( ast -> nodes [ 1 ] -> token , ast ); } } if ( ast -> name == \"ASSIGNMENT\" ) { auto symbol = ast -> nodes [ 0 ] -> token ; auto value = evaluate ( ast -> nodes [ 1 ]); variables_ [ symbol ] = value ; return value ; } if ( ast -> name == \"DOUBLE\" ) { return functions_ . evaluate ( \"double\" , ast ); } if ( ast -> name == \"INTEGER\" ) { return functions_ . evaluate ( \"integer\" , ast ); } if ( ast -> name == \"STRING\" ) { return functions_ . evaluate ( \"string\" , ast ); } if ( ast -> name == \"BOOLEAN\" ) { return functions_ . evaluate ( \"bool\" , ast ); } if ( ast -> name == \"ARRAY\" ) { return functions_ . evaluate ( \"array\" , ast ); } if ( ast -> name == \"CALL\" ) { auto ret = functions_ . evaluate ( ast -> nodes [ 0 ] -> token , ast -> nodes [ 1 ]); if ( ret . type () == typeid ( boost :: none )) { if ( variables_ . count ( ast -> nodes [ 0 ] -> token ) != 0 ) { return variables_ [ ast -> nodes [ 0 ] -> token ]; } return boost :: none ; } return ret ; } return boost :: none ; } } // namespace polaris Updated on 26 December 2020 at 00:59:10 UTC","title":"Source code"},{"location":"doxygen/markdown/Files/parser_8hpp/","text":"/home/runner/work/polaris/polaris/include/polaris/parser/parser.hpp # Namespaces # Name polaris Classes # Name class polaris::Parser Source code # // Copyright (c) 2020, OUXT-Polaris // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef POLARIS__PARSER__PARSER_HPP_ #define POLARIS__PARSER__PARSER_HPP_ #include <polaris/types/type_base.hpp> #include <polaris/built_in_functions/functions.hpp> #include <boost/any.hpp> #include <boost/optional.hpp> #include <peglib.h> #include <type_traits> #include <memory> #include <string> #include <unordered_map> namespace polaris { class Parser { public : explicit Parser ( bool verbose = true ); bool evaluate ( std :: string line ); template < typename T > const boost :: optional < T > getValue ( std :: string name ) const { if ( variables_ . count ( name ) == 0 ) { return boost :: none ; } boost :: any variable = variables_ . at ( name ); try { auto value = boost :: any_cast < const types :: TypeBase < T > &> ( variable ). getValue (); return value ; } catch ( boost :: bad_any_cast ) { return boost :: none ; } return boost :: none ; } private : boost :: any evaluate ( std :: shared_ptr < peg :: Ast > ast ); std :: unique_ptr < peg :: parser > parser_ptr_ ; std :: unordered_map < std :: string , boost :: any > variables_ ; bool verbose_ ; built_in_functions :: Functions functions_ ; }; } // namespace polaris #endif // POLARIS__PARSER__PARSER_HPP_ Updated on 26 December 2020 at 00:59:10 UTC","title":"/home/runner/work/polaris/polaris/include/polaris/parser/parser.hpp"},{"location":"doxygen/markdown/Files/parser_8hpp/#homerunnerworkpolarispolarisincludepolarisparserparserhpp","text":"","title":"/home/runner/work/polaris/polaris/include/polaris/parser/parser.hpp"},{"location":"doxygen/markdown/Files/parser_8hpp/#namespaces","text":"Name polaris","title":"Namespaces"},{"location":"doxygen/markdown/Files/parser_8hpp/#classes","text":"Name class polaris::Parser","title":"Classes"},{"location":"doxygen/markdown/Files/parser_8hpp/#source-code","text":"// Copyright (c) 2020, OUXT-Polaris // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef POLARIS__PARSER__PARSER_HPP_ #define POLARIS__PARSER__PARSER_HPP_ #include <polaris/types/type_base.hpp> #include <polaris/built_in_functions/functions.hpp> #include <boost/any.hpp> #include <boost/optional.hpp> #include <peglib.h> #include <type_traits> #include <memory> #include <string> #include <unordered_map> namespace polaris { class Parser { public : explicit Parser ( bool verbose = true ); bool evaluate ( std :: string line ); template < typename T > const boost :: optional < T > getValue ( std :: string name ) const { if ( variables_ . count ( name ) == 0 ) { return boost :: none ; } boost :: any variable = variables_ . at ( name ); try { auto value = boost :: any_cast < const types :: TypeBase < T > &> ( variable ). getValue (); return value ; } catch ( boost :: bad_any_cast ) { return boost :: none ; } return boost :: none ; } private : boost :: any evaluate ( std :: shared_ptr < peg :: Ast > ast ); std :: unique_ptr < peg :: parser > parser_ptr_ ; std :: unordered_map < std :: string , boost :: any > variables_ ; bool verbose_ ; built_in_functions :: Functions functions_ ; }; } // namespace polaris #endif // POLARIS__PARSER__PARSER_HPP_ Updated on 26 December 2020 at 00:59:10 UTC","title":"Source code"},{"location":"doxygen/markdown/Files/test__operator_8cpp/","text":"/home/runner/work/polaris/polaris/test/test_operator.cpp # Functions # Name int main (int argc, char ** argv) TEST (operator , addition0 ) TEST (operator , addition1 ) TEST (operator , addition2 ) TEST (operator , addition3 ) TEST (operator , subtraction0 ) TEST (operator , subtraction1 ) TEST (operator , subtraction2 ) TEST (operator , subtraction3 ) TEST (operator , multiplication0 ) TEST (operator , multiplication1 ) TEST (operator , multiplication2 ) TEST (operator , multiplication3 ) TEST (operator , division0 ) TEST (operator , division1 ) TEST (operator , division2 ) TEST (operator , division3 ) TEST (operator , quaternion0 ) Functions Documentation # function main # int main ( int argc , char ** argv ) function TEST # TEST ( operator , addition0 ) function TEST # TEST ( operator , addition1 ) function TEST # TEST ( operator , addition2 ) function TEST # TEST ( operator , addition3 ) function TEST # TEST ( operator , subtraction0 ) function TEST # TEST ( operator , subtraction1 ) function TEST # TEST ( operator , subtraction2 ) function TEST # TEST ( operator , subtraction3 ) function TEST # TEST ( operator , multiplication0 ) function TEST # TEST ( operator , multiplication1 ) function TEST # TEST ( operator , multiplication2 ) function TEST # TEST ( operator , multiplication3 ) function TEST # TEST ( operator , division0 ) function TEST # TEST ( operator , division1 ) function TEST # TEST ( operator , division2 ) function TEST # TEST ( operator , division3 ) function TEST # TEST ( operator , quaternion0 ) Source code # // Copyright (c) 2020, OUXT-Polaris // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #include <gtest/gtest.h> #include <polaris/parser/parser.hpp> #include <geometry_msgs/msg/quaternion.hpp> #include <vector> #include <string> TEST ( operator , addition0 ) { polaris :: Parser parser ; ASSERT_TRUE ( parser . evaluate ( \"let a = 1.0 + 3.0;\" )); const auto a = parser . getValue < double > ( \"a\" ); ASSERT_TRUE ( a ); ASSERT_DOUBLE_EQ ( a . get (), 4.0 ); } TEST ( operator , addition1 ) { polaris :: Parser parser ; ASSERT_TRUE ( parser . evaluate ( \"let a = 1 + 3.0;\" )); const auto a = parser . getValue < double > ( \"a\" ); ASSERT_TRUE ( a ); ASSERT_DOUBLE_EQ ( a . get (), 4.0 ); } TEST ( operator , addition2 ) { polaris :: Parser parser ; ASSERT_TRUE ( parser . evaluate ( \"let a = 1 + double(3.0);\" )); const auto a = parser . getValue < double > ( \"a\" ); ASSERT_TRUE ( a ); ASSERT_DOUBLE_EQ ( a . get (), 4.0 ); } TEST ( operator , addition3 ) { polaris :: Parser parser ; ASSERT_TRUE ( parser . evaluate ( \"let a = -1 + double(3.0);\" )); const auto a = parser . getValue < double > ( \"a\" ); ASSERT_TRUE ( a ); ASSERT_DOUBLE_EQ ( a . get (), 2.0 ); } TEST ( operator , subtraction0 ) { polaris :: Parser parser ; ASSERT_TRUE ( parser . evaluate ( \"let a = 1.0 - 3.0;\" )); const auto a = parser . getValue < double > ( \"a\" ); ASSERT_TRUE ( a ); ASSERT_DOUBLE_EQ ( a . get (), -2.0 ); } TEST ( operator , subtraction1 ) { polaris :: Parser parser ; ASSERT_TRUE ( parser . evaluate ( \"let a = 1 - 3.0;\" )); const auto a = parser . getValue < double > ( \"a\" ); ASSERT_TRUE ( a ); ASSERT_DOUBLE_EQ ( a . get (), -2.0 ); } TEST ( operator , subtraction2 ) { polaris :: Parser parser ; ASSERT_TRUE ( parser . evaluate ( \"let a = 1 - double(3.0);\" )); const auto a = parser . getValue < double > ( \"a\" ); ASSERT_TRUE ( a ); ASSERT_DOUBLE_EQ ( a . get (), -2.0 ); } TEST ( operator , subtraction3 ) { polaris :: Parser parser ; ASSERT_TRUE ( parser . evaluate ( \"let a = -1 - double(3.0);\" )); const auto a = parser . getValue < double > ( \"a\" ); ASSERT_TRUE ( a ); ASSERT_DOUBLE_EQ ( a . get (), -4.0 ); } TEST ( operator , multiplication0 ) { polaris :: Parser parser ; ASSERT_TRUE ( parser . evaluate ( \"let a = 1.0 * 3.0;\" )); const auto a = parser . getValue < double > ( \"a\" ); ASSERT_TRUE ( a ); ASSERT_DOUBLE_EQ ( a . get (), 3.0 ); } TEST ( operator , multiplication1 ) { polaris :: Parser parser ; ASSERT_TRUE ( parser . evaluate ( \"let a = 1 * 3.0;\" )); const auto a = parser . getValue < double > ( \"a\" ); ASSERT_TRUE ( a ); ASSERT_DOUBLE_EQ ( a . get (), 3.0 ); } TEST ( operator , multiplication2 ) { polaris :: Parser parser ; ASSERT_TRUE ( parser . evaluate ( \"let a = 1 * double(3.0);\" )); const auto a = parser . getValue < double > ( \"a\" ); ASSERT_TRUE ( a ); ASSERT_DOUBLE_EQ ( a . get (), 3.0 ); } TEST ( operator , multiplication3 ) { polaris :: Parser parser ; ASSERT_TRUE ( parser . evaluate ( \"let a = -1 * double(3.0);\" )); const auto a = parser . getValue < double > ( \"a\" ); ASSERT_TRUE ( a ); ASSERT_DOUBLE_EQ ( a . get (), -3.0 ); } TEST ( operator , division0 ) { polaris :: Parser parser ; ASSERT_TRUE ( parser . evaluate ( \"let a = 1.0 / 3.0;\" )); const auto a = parser . getValue < double > ( \"a\" ); ASSERT_TRUE ( a ); ASSERT_DOUBLE_EQ ( a . get (), 1.0 / 3.0 ); } TEST ( operator , division1 ) { polaris :: Parser parser ; ASSERT_TRUE ( parser . evaluate ( \"let a = 1 / 3.0;\" )); const auto a = parser . getValue < double > ( \"a\" ); ASSERT_TRUE ( a ); ASSERT_DOUBLE_EQ ( a . get (), 1.0 / 3.0 ); } TEST ( operator , division2 ) { polaris :: Parser parser ; ASSERT_TRUE ( parser . evaluate ( \"let a = 1 / double(3.0);\" )); const auto a = parser . getValue < double > ( \"a\" ); ASSERT_TRUE ( a ); ASSERT_DOUBLE_EQ ( a . get (), 1.0 / 3.0 ); } TEST ( operator , division3 ) { polaris :: Parser parser ; ASSERT_TRUE ( parser . evaluate ( \"let a = -1 / double(3.0);\" )); const auto a = parser . getValue < double > ( \"a\" ); ASSERT_TRUE ( a ); ASSERT_DOUBLE_EQ ( a . get (), -1.0 / 3.0 ); } TEST ( operator , quaternion0 ) { polaris :: Parser parser ; ASSERT_TRUE ( parser . evaluate ( \"let a = rpy(0,0,0)*quaternion(0.1,0,0.0,1);\" )); const auto a = parser . getValue < geometry_msgs :: msg :: Quaternion > ( \"a\" ); ASSERT_TRUE ( a ); ASSERT_DOUBLE_EQ ( a . get (). x , 0.1 ); ASSERT_DOUBLE_EQ ( a . get (). y , 0 ); ASSERT_DOUBLE_EQ ( a . get (). z , 0 ); ASSERT_DOUBLE_EQ ( a . get (). w , 1 ); } int main ( int argc , char ** argv ) { testing :: InitGoogleTest ( & argc , argv ); return RUN_ALL_TESTS (); } Updated on 26 December 2020 at 00:59:10 UTC","title":"/home/runner/work/polaris/polaris/test/test_operator.cpp"},{"location":"doxygen/markdown/Files/test__operator_8cpp/#homerunnerworkpolarispolaristesttest_operatorcpp","text":"","title":"/home/runner/work/polaris/polaris/test/test_operator.cpp"},{"location":"doxygen/markdown/Files/test__operator_8cpp/#functions","text":"Name int main (int argc, char ** argv) TEST (operator , addition0 ) TEST (operator , addition1 ) TEST (operator , addition2 ) TEST (operator , addition3 ) TEST (operator , subtraction0 ) TEST (operator , subtraction1 ) TEST (operator , subtraction2 ) TEST (operator , subtraction3 ) TEST (operator , multiplication0 ) TEST (operator , multiplication1 ) TEST (operator , multiplication2 ) TEST (operator , multiplication3 ) TEST (operator , division0 ) TEST (operator , division1 ) TEST (operator , division2 ) TEST (operator , division3 ) TEST (operator , quaternion0 )","title":"Functions"},{"location":"doxygen/markdown/Files/test__operator_8cpp/#functions-documentation","text":"","title":"Functions Documentation"},{"location":"doxygen/markdown/Files/test__operator_8cpp/#function-main","text":"int main ( int argc , char ** argv )","title":"function main"},{"location":"doxygen/markdown/Files/test__operator_8cpp/#function-test","text":"TEST ( operator , addition0 )","title":"function TEST"},{"location":"doxygen/markdown/Files/test__operator_8cpp/#function-test_1","text":"TEST ( operator , addition1 )","title":"function TEST"},{"location":"doxygen/markdown/Files/test__operator_8cpp/#function-test_2","text":"TEST ( operator , addition2 )","title":"function TEST"},{"location":"doxygen/markdown/Files/test__operator_8cpp/#function-test_3","text":"TEST ( operator , addition3 )","title":"function TEST"},{"location":"doxygen/markdown/Files/test__operator_8cpp/#function-test_4","text":"TEST ( operator , subtraction0 )","title":"function TEST"},{"location":"doxygen/markdown/Files/test__operator_8cpp/#function-test_5","text":"TEST ( operator , subtraction1 )","title":"function TEST"},{"location":"doxygen/markdown/Files/test__operator_8cpp/#function-test_6","text":"TEST ( operator , subtraction2 )","title":"function TEST"},{"location":"doxygen/markdown/Files/test__operator_8cpp/#function-test_7","text":"TEST ( operator , subtraction3 )","title":"function TEST"},{"location":"doxygen/markdown/Files/test__operator_8cpp/#function-test_8","text":"TEST ( operator , multiplication0 )","title":"function TEST"},{"location":"doxygen/markdown/Files/test__operator_8cpp/#function-test_9","text":"TEST ( operator , multiplication1 )","title":"function TEST"},{"location":"doxygen/markdown/Files/test__operator_8cpp/#function-test_10","text":"TEST ( operator , multiplication2 )","title":"function TEST"},{"location":"doxygen/markdown/Files/test__operator_8cpp/#function-test_11","text":"TEST ( operator , multiplication3 )","title":"function TEST"},{"location":"doxygen/markdown/Files/test__operator_8cpp/#function-test_12","text":"TEST ( operator , division0 )","title":"function TEST"},{"location":"doxygen/markdown/Files/test__operator_8cpp/#function-test_13","text":"TEST ( operator , division1 )","title":"function TEST"},{"location":"doxygen/markdown/Files/test__operator_8cpp/#function-test_14","text":"TEST ( operator , division2 )","title":"function TEST"},{"location":"doxygen/markdown/Files/test__operator_8cpp/#function-test_15","text":"TEST ( operator , division3 )","title":"function TEST"},{"location":"doxygen/markdown/Files/test__operator_8cpp/#function-test_16","text":"TEST ( operator , quaternion0 )","title":"function TEST"},{"location":"doxygen/markdown/Files/test__operator_8cpp/#source-code","text":"// Copyright (c) 2020, OUXT-Polaris // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #include <gtest/gtest.h> #include <polaris/parser/parser.hpp> #include <geometry_msgs/msg/quaternion.hpp> #include <vector> #include <string> TEST ( operator , addition0 ) { polaris :: Parser parser ; ASSERT_TRUE ( parser . evaluate ( \"let a = 1.0 + 3.0;\" )); const auto a = parser . getValue < double > ( \"a\" ); ASSERT_TRUE ( a ); ASSERT_DOUBLE_EQ ( a . get (), 4.0 ); } TEST ( operator , addition1 ) { polaris :: Parser parser ; ASSERT_TRUE ( parser . evaluate ( \"let a = 1 + 3.0;\" )); const auto a = parser . getValue < double > ( \"a\" ); ASSERT_TRUE ( a ); ASSERT_DOUBLE_EQ ( a . get (), 4.0 ); } TEST ( operator , addition2 ) { polaris :: Parser parser ; ASSERT_TRUE ( parser . evaluate ( \"let a = 1 + double(3.0);\" )); const auto a = parser . getValue < double > ( \"a\" ); ASSERT_TRUE ( a ); ASSERT_DOUBLE_EQ ( a . get (), 4.0 ); } TEST ( operator , addition3 ) { polaris :: Parser parser ; ASSERT_TRUE ( parser . evaluate ( \"let a = -1 + double(3.0);\" )); const auto a = parser . getValue < double > ( \"a\" ); ASSERT_TRUE ( a ); ASSERT_DOUBLE_EQ ( a . get (), 2.0 ); } TEST ( operator , subtraction0 ) { polaris :: Parser parser ; ASSERT_TRUE ( parser . evaluate ( \"let a = 1.0 - 3.0;\" )); const auto a = parser . getValue < double > ( \"a\" ); ASSERT_TRUE ( a ); ASSERT_DOUBLE_EQ ( a . get (), -2.0 ); } TEST ( operator , subtraction1 ) { polaris :: Parser parser ; ASSERT_TRUE ( parser . evaluate ( \"let a = 1 - 3.0;\" )); const auto a = parser . getValue < double > ( \"a\" ); ASSERT_TRUE ( a ); ASSERT_DOUBLE_EQ ( a . get (), -2.0 ); } TEST ( operator , subtraction2 ) { polaris :: Parser parser ; ASSERT_TRUE ( parser . evaluate ( \"let a = 1 - double(3.0);\" )); const auto a = parser . getValue < double > ( \"a\" ); ASSERT_TRUE ( a ); ASSERT_DOUBLE_EQ ( a . get (), -2.0 ); } TEST ( operator , subtraction3 ) { polaris :: Parser parser ; ASSERT_TRUE ( parser . evaluate ( \"let a = -1 - double(3.0);\" )); const auto a = parser . getValue < double > ( \"a\" ); ASSERT_TRUE ( a ); ASSERT_DOUBLE_EQ ( a . get (), -4.0 ); } TEST ( operator , multiplication0 ) { polaris :: Parser parser ; ASSERT_TRUE ( parser . evaluate ( \"let a = 1.0 * 3.0;\" )); const auto a = parser . getValue < double > ( \"a\" ); ASSERT_TRUE ( a ); ASSERT_DOUBLE_EQ ( a . get (), 3.0 ); } TEST ( operator , multiplication1 ) { polaris :: Parser parser ; ASSERT_TRUE ( parser . evaluate ( \"let a = 1 * 3.0;\" )); const auto a = parser . getValue < double > ( \"a\" ); ASSERT_TRUE ( a ); ASSERT_DOUBLE_EQ ( a . get (), 3.0 ); } TEST ( operator , multiplication2 ) { polaris :: Parser parser ; ASSERT_TRUE ( parser . evaluate ( \"let a = 1 * double(3.0);\" )); const auto a = parser . getValue < double > ( \"a\" ); ASSERT_TRUE ( a ); ASSERT_DOUBLE_EQ ( a . get (), 3.0 ); } TEST ( operator , multiplication3 ) { polaris :: Parser parser ; ASSERT_TRUE ( parser . evaluate ( \"let a = -1 * double(3.0);\" )); const auto a = parser . getValue < double > ( \"a\" ); ASSERT_TRUE ( a ); ASSERT_DOUBLE_EQ ( a . get (), -3.0 ); } TEST ( operator , division0 ) { polaris :: Parser parser ; ASSERT_TRUE ( parser . evaluate ( \"let a = 1.0 / 3.0;\" )); const auto a = parser . getValue < double > ( \"a\" ); ASSERT_TRUE ( a ); ASSERT_DOUBLE_EQ ( a . get (), 1.0 / 3.0 ); } TEST ( operator , division1 ) { polaris :: Parser parser ; ASSERT_TRUE ( parser . evaluate ( \"let a = 1 / 3.0;\" )); const auto a = parser . getValue < double > ( \"a\" ); ASSERT_TRUE ( a ); ASSERT_DOUBLE_EQ ( a . get (), 1.0 / 3.0 ); } TEST ( operator , division2 ) { polaris :: Parser parser ; ASSERT_TRUE ( parser . evaluate ( \"let a = 1 / double(3.0);\" )); const auto a = parser . getValue < double > ( \"a\" ); ASSERT_TRUE ( a ); ASSERT_DOUBLE_EQ ( a . get (), 1.0 / 3.0 ); } TEST ( operator , division3 ) { polaris :: Parser parser ; ASSERT_TRUE ( parser . evaluate ( \"let a = -1 / double(3.0);\" )); const auto a = parser . getValue < double > ( \"a\" ); ASSERT_TRUE ( a ); ASSERT_DOUBLE_EQ ( a . get (), -1.0 / 3.0 ); } TEST ( operator , quaternion0 ) { polaris :: Parser parser ; ASSERT_TRUE ( parser . evaluate ( \"let a = rpy(0,0,0)*quaternion(0.1,0,0.0,1);\" )); const auto a = parser . getValue < geometry_msgs :: msg :: Quaternion > ( \"a\" ); ASSERT_TRUE ( a ); ASSERT_DOUBLE_EQ ( a . get (). x , 0.1 ); ASSERT_DOUBLE_EQ ( a . get (). y , 0 ); ASSERT_DOUBLE_EQ ( a . get (). z , 0 ); ASSERT_DOUBLE_EQ ( a . get (). w , 1 ); } int main ( int argc , char ** argv ) { testing :: InitGoogleTest ( & argc , argv ); return RUN_ALL_TESTS (); } Updated on 26 December 2020 at 00:59:10 UTC","title":"Source code"},{"location":"doxygen/markdown/Files/test__types_8cpp/","text":"/home/runner/work/polaris/polaris/test/test_types.cpp # Functions # Name int main (int argc, char ** argv) TEST (types , empty ) TEST (types , double_type ) TEST (types , quaternion_type_0 ) TEST (types , quaternion_type_1 ) TEST (types , point_type_0 ) TEST (types , pose_type_0 ) TEST (types , pose_type_1 ) TEST (types , pose_type_2 ) TEST (types , string_0 ) TEST (types , string_1 ) TEST (types , bool_0 ) TEST (types , bool_1 ) TEST (types , bool_2 ) TEST (types , entity_0 ) TEST (types , array_0 ) TEST (types , array_1 ) TEST (types , array_2 ) TEST (types , array_3 ) TEST (types , array_4 ) TEST (types , array_5 ) TEST (types , array_6 ) Functions Documentation # function main # int main ( int argc , char ** argv ) function TEST # TEST ( types , empty ) function TEST # TEST ( types , double_type ) function TEST # TEST ( types , quaternion_type_0 ) function TEST # TEST ( types , quaternion_type_1 ) function TEST # TEST ( types , point_type_0 ) function TEST # TEST ( types , pose_type_0 ) function TEST # TEST ( types , pose_type_1 ) function TEST # TEST ( types , pose_type_2 ) function TEST # TEST ( types , string_0 ) function TEST # TEST ( types , string_1 ) function TEST # TEST ( types , bool_0 ) function TEST # TEST ( types , bool_1 ) function TEST # TEST ( types , bool_2 ) function TEST # TEST ( types , entity_0 ) function TEST # TEST ( types , array_0 ) function TEST # TEST ( types , array_1 ) function TEST # TEST ( types , array_2 ) function TEST # TEST ( types , array_3 ) function TEST # TEST ( types , array_4 ) function TEST # TEST ( types , array_5 ) function TEST # TEST ( types , array_6 ) Source code # // Copyright (c) 2020, OUXT-Polaris // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #include <gtest/gtest.h> #include <polaris/parser/parser.hpp> #include <geometry_msgs/msg/point.hpp> #include <geometry_msgs/msg/quaternion.hpp> #include <vector> #include <string> TEST ( types , empty ) { polaris :: Parser parser ; ASSERT_TRUE ( parser . evaluate ( \"\" )); } TEST ( types , double_type ) { polaris :: Parser parser ; ASSERT_TRUE ( parser . evaluate ( \"let a = 1.0;\" )); const auto a = parser . getValue < double > ( \"a\" ); ASSERT_TRUE ( a ); ASSERT_DOUBLE_EQ ( a . get (), 1.0 ); ASSERT_TRUE ( parser . evaluate ( \"1;\" )); ASSERT_TRUE ( parser . evaluate ( \"1.5;\" )); ASSERT_TRUE ( parser . evaluate ( \"-1.2;\" )); ASSERT_FALSE ( parser . evaluate ( \"-1.2a;\" )); ASSERT_FALSE ( parser . evaluate ( \"a3;\" )); ASSERT_TRUE ( parser . evaluate ( \"a;3;\" )); } TEST ( types , quaternion_type_0 ) { polaris :: Parser parser ; ASSERT_TRUE ( parser . evaluate ( \"let a = quaternion(0.0,0.0,0.0,1.0);\" )); const auto a = parser . getValue < geometry_msgs :: msg :: Quaternion > ( \"a\" ); ASSERT_TRUE ( a ); ASSERT_DOUBLE_EQ ( a . get (). x , 0.0 ); ASSERT_DOUBLE_EQ ( a . get (). y , 0.0 ); ASSERT_DOUBLE_EQ ( a . get (). z , 0.0 ); ASSERT_DOUBLE_EQ ( a . get (). w , 1.0 ); } TEST ( types , quaternion_type_1 ) { polaris :: Parser parser ; ASSERT_TRUE ( parser . evaluate ( \"let w = 1.0;let a = quaternion(double(0.0),0,0.0,w);\" )); const auto a = parser . getValue < geometry_msgs :: msg :: Quaternion > ( \"a\" ); ASSERT_TRUE ( a ); ASSERT_DOUBLE_EQ ( a . get (). x , 0.0 ); ASSERT_DOUBLE_EQ ( a . get (). y , 0.0 ); ASSERT_DOUBLE_EQ ( a . get (). z , 0.0 ); ASSERT_DOUBLE_EQ ( a . get (). w , 1.0 ); const auto w = parser . getValue < double > ( \"w\" ); ASSERT_TRUE ( w ); ASSERT_DOUBLE_EQ ( w . get (), 1.0 ); const auto x = parser . getValue < double > ( \"x\" ); ASSERT_FALSE ( x ); } TEST ( types , point_type_0 ) { polaris :: Parser parser ; ASSERT_TRUE ( parser . evaluate ( \"let a = point(0.0,0.0,1.0);\" )); const auto a = parser . getValue < geometry_msgs :: msg :: Point > ( \"a\" ); ASSERT_TRUE ( a ); ASSERT_DOUBLE_EQ ( a . get (). x , 0.0 ); ASSERT_DOUBLE_EQ ( a . get (). y , 0.0 ); ASSERT_DOUBLE_EQ ( a . get (). z , 1.0 ); } TEST ( types , pose_type_0 ) { polaris :: Parser parser ; ASSERT_TRUE ( parser . evaluate ( \"let a = pose(point(1,2,3),quaternion(0,0,0,1));\" )); const auto a = parser . getValue < geometry_msgs :: msg :: Pose > ( \"a\" ); ASSERT_TRUE ( a ); ASSERT_DOUBLE_EQ ( a . get (). position . x , 1.0 ); ASSERT_DOUBLE_EQ ( a . get (). position . y , 2.0 ); ASSERT_DOUBLE_EQ ( a . get (). position . z , 3.0 ); ASSERT_DOUBLE_EQ ( a . get (). orientation . x , 0.0 ); ASSERT_DOUBLE_EQ ( a . get (). orientation . y , 0.0 ); ASSERT_DOUBLE_EQ ( a . get (). orientation . z , 0.0 ); ASSERT_DOUBLE_EQ ( a . get (). orientation . w , 1.0 ); } TEST ( types , pose_type_1 ) { polaris :: Parser parser ; ASSERT_TRUE ( parser . evaluate ( \"let p = point(1,2,3);let a = pose(p,quaternion(0,0,0,1));\" )); const auto a = parser . getValue < geometry_msgs :: msg :: Pose > ( \"a\" ); ASSERT_TRUE ( a ); ASSERT_DOUBLE_EQ ( a . get (). position . x , 1.0 ); ASSERT_DOUBLE_EQ ( a . get (). position . y , 2.0 ); ASSERT_DOUBLE_EQ ( a . get (). position . z , 3.0 ); ASSERT_DOUBLE_EQ ( a . get (). orientation . x , 0.0 ); ASSERT_DOUBLE_EQ ( a . get (). orientation . y , 0.0 ); ASSERT_DOUBLE_EQ ( a . get (). orientation . z , 0.0 ); ASSERT_DOUBLE_EQ ( a . get (). orientation . w , 1.0 ); } TEST ( types , pose_type_2 ) { polaris :: Parser parser ; ASSERT_TRUE ( parser . evaluate ( \"let q = quaternion(0,0,0,1);let a = pose(point(1,2,3),q);\" )); const auto a = parser . getValue < geometry_msgs :: msg :: Pose > ( \"a\" ); ASSERT_TRUE ( a ); ASSERT_DOUBLE_EQ ( a . get (). position . x , 1.0 ); ASSERT_DOUBLE_EQ ( a . get (). position . y , 2.0 ); ASSERT_DOUBLE_EQ ( a . get (). position . z , 3.0 ); ASSERT_DOUBLE_EQ ( a . get (). orientation . x , 0.0 ); ASSERT_DOUBLE_EQ ( a . get (). orientation . y , 0.0 ); ASSERT_DOUBLE_EQ ( a . get (). orientation . z , 0.0 ); ASSERT_DOUBLE_EQ ( a . get (). orientation . w , 1.0 ); } TEST ( types , string_0 ) { std :: string code = R \" ( let a = string(\"test\"); ) \" ; polaris :: Parser parser ; ASSERT_TRUE ( parser . evaluate ( code )); const auto a = parser . getValue < std :: string > ( \"a\" ); ASSERT_TRUE ( a ); ASSERT_STREQ ( a . get (). c_str (), \"test\" ); } TEST ( types , string_1 ) { std :: string code = R \" ( let a = \"test\"; ) \" ; polaris :: Parser parser ; ASSERT_TRUE ( parser . evaluate ( code )); const auto a = parser . getValue < std :: string > ( \"a\" ); ASSERT_TRUE ( a ); ASSERT_STREQ ( a . get (). c_str (), \"test\" ); } TEST ( types , bool_0 ) { std :: string code = R \" ( let a = true; ) \" ; polaris :: Parser parser ; ASSERT_TRUE ( parser . evaluate ( code )); const auto a = parser . getValue < bool > ( \"a\" ); ASSERT_TRUE ( a ); ASSERT_EQ ( a . get (), true ); } TEST ( types , bool_1 ) { std :: string code = R \" ( let a = false; ) \" ; polaris :: Parser parser ; ASSERT_TRUE ( parser . evaluate ( code )); const auto a = parser . getValue < bool > ( \"a\" ); ASSERT_TRUE ( a ); ASSERT_EQ ( a . get (), false ); } TEST ( types , bool_2 ) { std :: string code = R \" ( let a = bool(true); ) \" ; polaris :: Parser parser ; ASSERT_TRUE ( parser . evaluate ( code )); const auto a = parser . getValue < bool > ( \"a\" ); ASSERT_TRUE ( a ); ASSERT_EQ ( a . get (), true ); } TEST ( types , entity_0 ) { std :: string code = R \" ( let a = entity(pose(point(1,2,3),quaternion(0,0,0,1)), [\"bouy\"], [point(0,1,2), point(2,3,4), point(3,2,3)]); ) \" ; polaris :: Parser parser ; ASSERT_TRUE ( parser . evaluate ( code )); const auto a = parser . getValue < polaris :: types :: Entity > ( \"a\" ); ASSERT_TRUE ( a ); ASSERT_DOUBLE_EQ ( a . get (). pose . position . x , 1 ); ASSERT_DOUBLE_EQ ( a . get (). pose . position . y , 2 ); ASSERT_DOUBLE_EQ ( a . get (). pose . position . z , 3 ); ASSERT_EQ ( a . get (). type . size (), static_cast < size_t > ( 1 )); ASSERT_STREQ ( a . get (). type [ 0 ]. c_str (), \"bouy\" ); ASSERT_EQ ( a . get (). polygon . size (), static_cast < size_t > ( 3 )); ASSERT_DOUBLE_EQ ( a . get (). polygon [ 0 ]. x , 0 ); ASSERT_DOUBLE_EQ ( a . get (). polygon [ 0 ]. y , 1 ); ASSERT_DOUBLE_EQ ( a . get (). polygon [ 0 ]. z , 2 ); ASSERT_DOUBLE_EQ ( a . get (). polygon [ 1 ]. x , 2 ); ASSERT_DOUBLE_EQ ( a . get (). polygon [ 1 ]. y , 3 ); ASSERT_DOUBLE_EQ ( a . get (). polygon [ 1 ]. z , 4 ); ASSERT_DOUBLE_EQ ( a . get (). polygon [ 2 ]. x , 3 ); ASSERT_DOUBLE_EQ ( a . get (). polygon [ 2 ]. y , 2 ); ASSERT_DOUBLE_EQ ( a . get (). polygon [ 2 ]. z , 3 ); } TEST ( types , array_0 ) { std :: string code = R \" ( let a = [1,2,3]; ) \" ; polaris :: Parser parser ; ASSERT_TRUE ( parser . evaluate ( code )); const auto a = parser . getValue < std :: vector < int >> ( \"a\" ); ASSERT_TRUE ( a ); ASSERT_EQ ( a . get (). size (), static_cast < size_t > ( 3 )); ASSERT_EQ ( a . get ()[ 0 ], 1 ); ASSERT_EQ ( a . get ()[ 1 ], 2 ); ASSERT_EQ ( a . get ()[ 2 ], 3 ); } TEST ( types , array_1 ) { std :: string code = R \" ( let a = [1.0,2.9,3.0,12.0]; ) \" ; polaris :: Parser parser ; ASSERT_TRUE ( parser . evaluate ( code )); const auto a = parser . getValue < std :: vector < double >> ( \"a\" ); ASSERT_TRUE ( a ); ASSERT_DOUBLE_EQ ( a . get (). size (), static_cast < size_t > ( 4 )); ASSERT_DOUBLE_EQ ( a . get ()[ 0 ], 1.0 ); ASSERT_DOUBLE_EQ ( a . get ()[ 1 ], 2.9 ); ASSERT_DOUBLE_EQ ( a . get ()[ 2 ], 3.0 ); ASSERT_DOUBLE_EQ ( a . get ()[ 3 ], 12.0 ); } TEST ( types , array_2 ) { std :: string code = R \" ( let a = [\"a\",\"b\"]; ) \" ; polaris :: Parser parser ; ASSERT_TRUE ( parser . evaluate ( code )); const auto a = parser . getValue < std :: vector < std :: string >> ( \"a\" ); ASSERT_TRUE ( a ); ASSERT_DOUBLE_EQ ( a . get (). size (), static_cast < size_t > ( 2 )); ASSERT_STREQ ( a . get ()[ 0 ]. c_str (), \"a\" ); ASSERT_STREQ ( a . get ()[ 1 ]. c_str (), \"b\" ); } TEST ( types , array_3 ) { std :: string code = R \" ( let a=[point(1,2,3), point(1,2,5)]; ) \" ; polaris :: Parser parser ; ASSERT_TRUE ( parser . evaluate ( code )); const auto a = parser . getValue < std :: vector < geometry_msgs :: msg :: Point >> ( \"a\" ); ASSERT_TRUE ( a ); ASSERT_EQ ( a . get (). size (), static_cast < size_t > ( 2 )); ASSERT_DOUBLE_EQ ( a . get ()[ 0 ]. x , 1.0 ); ASSERT_DOUBLE_EQ ( a . get ()[ 0 ]. y , 2.0 ); ASSERT_DOUBLE_EQ ( a . get ()[ 0 ]. z , 3.0 ); ASSERT_DOUBLE_EQ ( a . get ()[ 1 ]. x , 1.0 ); ASSERT_DOUBLE_EQ ( a . get ()[ 1 ]. y , 2.0 ); ASSERT_DOUBLE_EQ ( a . get ()[ 1 ]. z , 5.0 ); } TEST ( types , array_4 ) { std :: string code = R \" ( let p = point(1,2,3);let a=[p, point(1,2,5)]; ) \" ; polaris :: Parser parser ; ASSERT_TRUE ( parser . evaluate ( code )); const auto a = parser . getValue < std :: vector < geometry_msgs :: msg :: Point >> ( \"a\" ); ASSERT_TRUE ( a ); ASSERT_EQ ( a . get (). size (), static_cast < size_t > ( 2 )); ASSERT_DOUBLE_EQ ( a . get ()[ 0 ]. x , 1.0 ); ASSERT_DOUBLE_EQ ( a . get ()[ 0 ]. y , 2.0 ); ASSERT_DOUBLE_EQ ( a . get ()[ 0 ]. z , 3.0 ); ASSERT_DOUBLE_EQ ( a . get ()[ 1 ]. x , 1.0 ); ASSERT_DOUBLE_EQ ( a . get ()[ 1 ]. y , 2.0 ); ASSERT_DOUBLE_EQ ( a . get ()[ 1 ]. z , 5.0 ); } TEST ( types , array_5 ) { std :: string code = R \" ( let a = entity(pose(point(1,2,3),quaternion(0,0,0,1)), [\"bouy\"], [point(0,1,2), point(2,3,4), point(3,2,3)]); let b = entity(pose(point(1,2,3),quaternion(0,0,0,1)), [\"bouy\"], [point(0,1,2), point(2,3,4), point(3,2,3)]); let c = [a,b]; ) \" ; polaris :: Parser parser ; ASSERT_TRUE ( parser . evaluate ( code )); const auto c = parser . getValue < std :: vector < polaris :: types :: Entity >> ( \"c\" ); ASSERT_TRUE ( c ); ASSERT_EQ ( c . get (). size (), static_cast < size_t > ( 2 )); const auto a = parser . getValue < polaris :: types :: Entity > ( \"a\" ); ASSERT_TRUE ( a ); ASSERT_DOUBLE_EQ ( a . get (). pose . position . x , 1 ); ASSERT_DOUBLE_EQ ( a . get (). pose . position . y , 2 ); ASSERT_DOUBLE_EQ ( a . get (). pose . position . z , 3 ); ASSERT_EQ ( a . get (). type . size (), static_cast < size_t > ( 1 )); ASSERT_STREQ ( a . get (). type [ 0 ]. c_str (), \"bouy\" ); ASSERT_EQ ( a . get (). polygon . size (), static_cast < size_t > ( 3 )); ASSERT_DOUBLE_EQ ( a . get (). polygon [ 0 ]. x , 0 ); ASSERT_DOUBLE_EQ ( a . get (). polygon [ 0 ]. y , 1 ); ASSERT_DOUBLE_EQ ( a . get (). polygon [ 0 ]. z , 2 ); ASSERT_DOUBLE_EQ ( a . get (). polygon [ 1 ]. x , 2 ); ASSERT_DOUBLE_EQ ( a . get (). polygon [ 1 ]. y , 3 ); ASSERT_DOUBLE_EQ ( a . get (). polygon [ 1 ]. z , 4 ); ASSERT_DOUBLE_EQ ( a . get (). polygon [ 2 ]. x , 3 ); ASSERT_DOUBLE_EQ ( a . get (). polygon [ 2 ]. y , 2 ); ASSERT_DOUBLE_EQ ( a . get (). polygon [ 2 ]. z , 3 ); } TEST ( types , array_6 ) { std :: string code = R \" ( let a=[true, false]; ) \" ; polaris :: Parser parser ; ASSERT_TRUE ( parser . evaluate ( code )); const auto a = parser . getValue < std :: vector < bool >> ( \"a\" ); ASSERT_TRUE ( a ); ASSERT_EQ ( a . get (). size (), static_cast < size_t > ( 2 )); ASSERT_EQ ( a . get ()[ 0 ], true ); ASSERT_EQ ( a . get ()[ 1 ], false ); } int main ( int argc , char ** argv ) { testing :: InitGoogleTest ( & argc , argv ); return RUN_ALL_TESTS (); } Updated on 26 December 2020 at 00:59:10 UTC","title":"/home/runner/work/polaris/polaris/test/test_types.cpp"},{"location":"doxygen/markdown/Files/test__types_8cpp/#homerunnerworkpolarispolaristesttest_typescpp","text":"","title":"/home/runner/work/polaris/polaris/test/test_types.cpp"},{"location":"doxygen/markdown/Files/test__types_8cpp/#functions","text":"Name int main (int argc, char ** argv) TEST (types , empty ) TEST (types , double_type ) TEST (types , quaternion_type_0 ) TEST (types , quaternion_type_1 ) TEST (types , point_type_0 ) TEST (types , pose_type_0 ) TEST (types , pose_type_1 ) TEST (types , pose_type_2 ) TEST (types , string_0 ) TEST (types , string_1 ) TEST (types , bool_0 ) TEST (types , bool_1 ) TEST (types , bool_2 ) TEST (types , entity_0 ) TEST (types , array_0 ) TEST (types , array_1 ) TEST (types , array_2 ) TEST (types , array_3 ) TEST (types , array_4 ) TEST (types , array_5 ) TEST (types , array_6 )","title":"Functions"},{"location":"doxygen/markdown/Files/test__types_8cpp/#functions-documentation","text":"","title":"Functions Documentation"},{"location":"doxygen/markdown/Files/test__types_8cpp/#function-main","text":"int main ( int argc , char ** argv )","title":"function main"},{"location":"doxygen/markdown/Files/test__types_8cpp/#function-test","text":"TEST ( types , empty )","title":"function TEST"},{"location":"doxygen/markdown/Files/test__types_8cpp/#function-test_1","text":"TEST ( types , double_type )","title":"function TEST"},{"location":"doxygen/markdown/Files/test__types_8cpp/#function-test_2","text":"TEST ( types , quaternion_type_0 )","title":"function TEST"},{"location":"doxygen/markdown/Files/test__types_8cpp/#function-test_3","text":"TEST ( types , quaternion_type_1 )","title":"function TEST"},{"location":"doxygen/markdown/Files/test__types_8cpp/#function-test_4","text":"TEST ( types , point_type_0 )","title":"function TEST"},{"location":"doxygen/markdown/Files/test__types_8cpp/#function-test_5","text":"TEST ( types , pose_type_0 )","title":"function TEST"},{"location":"doxygen/markdown/Files/test__types_8cpp/#function-test_6","text":"TEST ( types , pose_type_1 )","title":"function TEST"},{"location":"doxygen/markdown/Files/test__types_8cpp/#function-test_7","text":"TEST ( types , pose_type_2 )","title":"function TEST"},{"location":"doxygen/markdown/Files/test__types_8cpp/#function-test_8","text":"TEST ( types , string_0 )","title":"function TEST"},{"location":"doxygen/markdown/Files/test__types_8cpp/#function-test_9","text":"TEST ( types , string_1 )","title":"function TEST"},{"location":"doxygen/markdown/Files/test__types_8cpp/#function-test_10","text":"TEST ( types , bool_0 )","title":"function TEST"},{"location":"doxygen/markdown/Files/test__types_8cpp/#function-test_11","text":"TEST ( types , bool_1 )","title":"function TEST"},{"location":"doxygen/markdown/Files/test__types_8cpp/#function-test_12","text":"TEST ( types , bool_2 )","title":"function TEST"},{"location":"doxygen/markdown/Files/test__types_8cpp/#function-test_13","text":"TEST ( types , entity_0 )","title":"function TEST"},{"location":"doxygen/markdown/Files/test__types_8cpp/#function-test_14","text":"TEST ( types , array_0 )","title":"function TEST"},{"location":"doxygen/markdown/Files/test__types_8cpp/#function-test_15","text":"TEST ( types , array_1 )","title":"function TEST"},{"location":"doxygen/markdown/Files/test__types_8cpp/#function-test_16","text":"TEST ( types , array_2 )","title":"function TEST"},{"location":"doxygen/markdown/Files/test__types_8cpp/#function-test_17","text":"TEST ( types , array_3 )","title":"function TEST"},{"location":"doxygen/markdown/Files/test__types_8cpp/#function-test_18","text":"TEST ( types , array_4 )","title":"function TEST"},{"location":"doxygen/markdown/Files/test__types_8cpp/#function-test_19","text":"TEST ( types , array_5 )","title":"function TEST"},{"location":"doxygen/markdown/Files/test__types_8cpp/#function-test_20","text":"TEST ( types , array_6 )","title":"function TEST"},{"location":"doxygen/markdown/Files/test__types_8cpp/#source-code","text":"// Copyright (c) 2020, OUXT-Polaris // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #include <gtest/gtest.h> #include <polaris/parser/parser.hpp> #include <geometry_msgs/msg/point.hpp> #include <geometry_msgs/msg/quaternion.hpp> #include <vector> #include <string> TEST ( types , empty ) { polaris :: Parser parser ; ASSERT_TRUE ( parser . evaluate ( \"\" )); } TEST ( types , double_type ) { polaris :: Parser parser ; ASSERT_TRUE ( parser . evaluate ( \"let a = 1.0;\" )); const auto a = parser . getValue < double > ( \"a\" ); ASSERT_TRUE ( a ); ASSERT_DOUBLE_EQ ( a . get (), 1.0 ); ASSERT_TRUE ( parser . evaluate ( \"1;\" )); ASSERT_TRUE ( parser . evaluate ( \"1.5;\" )); ASSERT_TRUE ( parser . evaluate ( \"-1.2;\" )); ASSERT_FALSE ( parser . evaluate ( \"-1.2a;\" )); ASSERT_FALSE ( parser . evaluate ( \"a3;\" )); ASSERT_TRUE ( parser . evaluate ( \"a;3;\" )); } TEST ( types , quaternion_type_0 ) { polaris :: Parser parser ; ASSERT_TRUE ( parser . evaluate ( \"let a = quaternion(0.0,0.0,0.0,1.0);\" )); const auto a = parser . getValue < geometry_msgs :: msg :: Quaternion > ( \"a\" ); ASSERT_TRUE ( a ); ASSERT_DOUBLE_EQ ( a . get (). x , 0.0 ); ASSERT_DOUBLE_EQ ( a . get (). y , 0.0 ); ASSERT_DOUBLE_EQ ( a . get (). z , 0.0 ); ASSERT_DOUBLE_EQ ( a . get (). w , 1.0 ); } TEST ( types , quaternion_type_1 ) { polaris :: Parser parser ; ASSERT_TRUE ( parser . evaluate ( \"let w = 1.0;let a = quaternion(double(0.0),0,0.0,w);\" )); const auto a = parser . getValue < geometry_msgs :: msg :: Quaternion > ( \"a\" ); ASSERT_TRUE ( a ); ASSERT_DOUBLE_EQ ( a . get (). x , 0.0 ); ASSERT_DOUBLE_EQ ( a . get (). y , 0.0 ); ASSERT_DOUBLE_EQ ( a . get (). z , 0.0 ); ASSERT_DOUBLE_EQ ( a . get (). w , 1.0 ); const auto w = parser . getValue < double > ( \"w\" ); ASSERT_TRUE ( w ); ASSERT_DOUBLE_EQ ( w . get (), 1.0 ); const auto x = parser . getValue < double > ( \"x\" ); ASSERT_FALSE ( x ); } TEST ( types , point_type_0 ) { polaris :: Parser parser ; ASSERT_TRUE ( parser . evaluate ( \"let a = point(0.0,0.0,1.0);\" )); const auto a = parser . getValue < geometry_msgs :: msg :: Point > ( \"a\" ); ASSERT_TRUE ( a ); ASSERT_DOUBLE_EQ ( a . get (). x , 0.0 ); ASSERT_DOUBLE_EQ ( a . get (). y , 0.0 ); ASSERT_DOUBLE_EQ ( a . get (). z , 1.0 ); } TEST ( types , pose_type_0 ) { polaris :: Parser parser ; ASSERT_TRUE ( parser . evaluate ( \"let a = pose(point(1,2,3),quaternion(0,0,0,1));\" )); const auto a = parser . getValue < geometry_msgs :: msg :: Pose > ( \"a\" ); ASSERT_TRUE ( a ); ASSERT_DOUBLE_EQ ( a . get (). position . x , 1.0 ); ASSERT_DOUBLE_EQ ( a . get (). position . y , 2.0 ); ASSERT_DOUBLE_EQ ( a . get (). position . z , 3.0 ); ASSERT_DOUBLE_EQ ( a . get (). orientation . x , 0.0 ); ASSERT_DOUBLE_EQ ( a . get (). orientation . y , 0.0 ); ASSERT_DOUBLE_EQ ( a . get (). orientation . z , 0.0 ); ASSERT_DOUBLE_EQ ( a . get (). orientation . w , 1.0 ); } TEST ( types , pose_type_1 ) { polaris :: Parser parser ; ASSERT_TRUE ( parser . evaluate ( \"let p = point(1,2,3);let a = pose(p,quaternion(0,0,0,1));\" )); const auto a = parser . getValue < geometry_msgs :: msg :: Pose > ( \"a\" ); ASSERT_TRUE ( a ); ASSERT_DOUBLE_EQ ( a . get (). position . x , 1.0 ); ASSERT_DOUBLE_EQ ( a . get (). position . y , 2.0 ); ASSERT_DOUBLE_EQ ( a . get (). position . z , 3.0 ); ASSERT_DOUBLE_EQ ( a . get (). orientation . x , 0.0 ); ASSERT_DOUBLE_EQ ( a . get (). orientation . y , 0.0 ); ASSERT_DOUBLE_EQ ( a . get (). orientation . z , 0.0 ); ASSERT_DOUBLE_EQ ( a . get (). orientation . w , 1.0 ); } TEST ( types , pose_type_2 ) { polaris :: Parser parser ; ASSERT_TRUE ( parser . evaluate ( \"let q = quaternion(0,0,0,1);let a = pose(point(1,2,3),q);\" )); const auto a = parser . getValue < geometry_msgs :: msg :: Pose > ( \"a\" ); ASSERT_TRUE ( a ); ASSERT_DOUBLE_EQ ( a . get (). position . x , 1.0 ); ASSERT_DOUBLE_EQ ( a . get (). position . y , 2.0 ); ASSERT_DOUBLE_EQ ( a . get (). position . z , 3.0 ); ASSERT_DOUBLE_EQ ( a . get (). orientation . x , 0.0 ); ASSERT_DOUBLE_EQ ( a . get (). orientation . y , 0.0 ); ASSERT_DOUBLE_EQ ( a . get (). orientation . z , 0.0 ); ASSERT_DOUBLE_EQ ( a . get (). orientation . w , 1.0 ); } TEST ( types , string_0 ) { std :: string code = R \" ( let a = string(\"test\"); ) \" ; polaris :: Parser parser ; ASSERT_TRUE ( parser . evaluate ( code )); const auto a = parser . getValue < std :: string > ( \"a\" ); ASSERT_TRUE ( a ); ASSERT_STREQ ( a . get (). c_str (), \"test\" ); } TEST ( types , string_1 ) { std :: string code = R \" ( let a = \"test\"; ) \" ; polaris :: Parser parser ; ASSERT_TRUE ( parser . evaluate ( code )); const auto a = parser . getValue < std :: string > ( \"a\" ); ASSERT_TRUE ( a ); ASSERT_STREQ ( a . get (). c_str (), \"test\" ); } TEST ( types , bool_0 ) { std :: string code = R \" ( let a = true; ) \" ; polaris :: Parser parser ; ASSERT_TRUE ( parser . evaluate ( code )); const auto a = parser . getValue < bool > ( \"a\" ); ASSERT_TRUE ( a ); ASSERT_EQ ( a . get (), true ); } TEST ( types , bool_1 ) { std :: string code = R \" ( let a = false; ) \" ; polaris :: Parser parser ; ASSERT_TRUE ( parser . evaluate ( code )); const auto a = parser . getValue < bool > ( \"a\" ); ASSERT_TRUE ( a ); ASSERT_EQ ( a . get (), false ); } TEST ( types , bool_2 ) { std :: string code = R \" ( let a = bool(true); ) \" ; polaris :: Parser parser ; ASSERT_TRUE ( parser . evaluate ( code )); const auto a = parser . getValue < bool > ( \"a\" ); ASSERT_TRUE ( a ); ASSERT_EQ ( a . get (), true ); } TEST ( types , entity_0 ) { std :: string code = R \" ( let a = entity(pose(point(1,2,3),quaternion(0,0,0,1)), [\"bouy\"], [point(0,1,2), point(2,3,4), point(3,2,3)]); ) \" ; polaris :: Parser parser ; ASSERT_TRUE ( parser . evaluate ( code )); const auto a = parser . getValue < polaris :: types :: Entity > ( \"a\" ); ASSERT_TRUE ( a ); ASSERT_DOUBLE_EQ ( a . get (). pose . position . x , 1 ); ASSERT_DOUBLE_EQ ( a . get (). pose . position . y , 2 ); ASSERT_DOUBLE_EQ ( a . get (). pose . position . z , 3 ); ASSERT_EQ ( a . get (). type . size (), static_cast < size_t > ( 1 )); ASSERT_STREQ ( a . get (). type [ 0 ]. c_str (), \"bouy\" ); ASSERT_EQ ( a . get (). polygon . size (), static_cast < size_t > ( 3 )); ASSERT_DOUBLE_EQ ( a . get (). polygon [ 0 ]. x , 0 ); ASSERT_DOUBLE_EQ ( a . get (). polygon [ 0 ]. y , 1 ); ASSERT_DOUBLE_EQ ( a . get (). polygon [ 0 ]. z , 2 ); ASSERT_DOUBLE_EQ ( a . get (). polygon [ 1 ]. x , 2 ); ASSERT_DOUBLE_EQ ( a . get (). polygon [ 1 ]. y , 3 ); ASSERT_DOUBLE_EQ ( a . get (). polygon [ 1 ]. z , 4 ); ASSERT_DOUBLE_EQ ( a . get (). polygon [ 2 ]. x , 3 ); ASSERT_DOUBLE_EQ ( a . get (). polygon [ 2 ]. y , 2 ); ASSERT_DOUBLE_EQ ( a . get (). polygon [ 2 ]. z , 3 ); } TEST ( types , array_0 ) { std :: string code = R \" ( let a = [1,2,3]; ) \" ; polaris :: Parser parser ; ASSERT_TRUE ( parser . evaluate ( code )); const auto a = parser . getValue < std :: vector < int >> ( \"a\" ); ASSERT_TRUE ( a ); ASSERT_EQ ( a . get (). size (), static_cast < size_t > ( 3 )); ASSERT_EQ ( a . get ()[ 0 ], 1 ); ASSERT_EQ ( a . get ()[ 1 ], 2 ); ASSERT_EQ ( a . get ()[ 2 ], 3 ); } TEST ( types , array_1 ) { std :: string code = R \" ( let a = [1.0,2.9,3.0,12.0]; ) \" ; polaris :: Parser parser ; ASSERT_TRUE ( parser . evaluate ( code )); const auto a = parser . getValue < std :: vector < double >> ( \"a\" ); ASSERT_TRUE ( a ); ASSERT_DOUBLE_EQ ( a . get (). size (), static_cast < size_t > ( 4 )); ASSERT_DOUBLE_EQ ( a . get ()[ 0 ], 1.0 ); ASSERT_DOUBLE_EQ ( a . get ()[ 1 ], 2.9 ); ASSERT_DOUBLE_EQ ( a . get ()[ 2 ], 3.0 ); ASSERT_DOUBLE_EQ ( a . get ()[ 3 ], 12.0 ); } TEST ( types , array_2 ) { std :: string code = R \" ( let a = [\"a\",\"b\"]; ) \" ; polaris :: Parser parser ; ASSERT_TRUE ( parser . evaluate ( code )); const auto a = parser . getValue < std :: vector < std :: string >> ( \"a\" ); ASSERT_TRUE ( a ); ASSERT_DOUBLE_EQ ( a . get (). size (), static_cast < size_t > ( 2 )); ASSERT_STREQ ( a . get ()[ 0 ]. c_str (), \"a\" ); ASSERT_STREQ ( a . get ()[ 1 ]. c_str (), \"b\" ); } TEST ( types , array_3 ) { std :: string code = R \" ( let a=[point(1,2,3), point(1,2,5)]; ) \" ; polaris :: Parser parser ; ASSERT_TRUE ( parser . evaluate ( code )); const auto a = parser . getValue < std :: vector < geometry_msgs :: msg :: Point >> ( \"a\" ); ASSERT_TRUE ( a ); ASSERT_EQ ( a . get (). size (), static_cast < size_t > ( 2 )); ASSERT_DOUBLE_EQ ( a . get ()[ 0 ]. x , 1.0 ); ASSERT_DOUBLE_EQ ( a . get ()[ 0 ]. y , 2.0 ); ASSERT_DOUBLE_EQ ( a . get ()[ 0 ]. z , 3.0 ); ASSERT_DOUBLE_EQ ( a . get ()[ 1 ]. x , 1.0 ); ASSERT_DOUBLE_EQ ( a . get ()[ 1 ]. y , 2.0 ); ASSERT_DOUBLE_EQ ( a . get ()[ 1 ]. z , 5.0 ); } TEST ( types , array_4 ) { std :: string code = R \" ( let p = point(1,2,3);let a=[p, point(1,2,5)]; ) \" ; polaris :: Parser parser ; ASSERT_TRUE ( parser . evaluate ( code )); const auto a = parser . getValue < std :: vector < geometry_msgs :: msg :: Point >> ( \"a\" ); ASSERT_TRUE ( a ); ASSERT_EQ ( a . get (). size (), static_cast < size_t > ( 2 )); ASSERT_DOUBLE_EQ ( a . get ()[ 0 ]. x , 1.0 ); ASSERT_DOUBLE_EQ ( a . get ()[ 0 ]. y , 2.0 ); ASSERT_DOUBLE_EQ ( a . get ()[ 0 ]. z , 3.0 ); ASSERT_DOUBLE_EQ ( a . get ()[ 1 ]. x , 1.0 ); ASSERT_DOUBLE_EQ ( a . get ()[ 1 ]. y , 2.0 ); ASSERT_DOUBLE_EQ ( a . get ()[ 1 ]. z , 5.0 ); } TEST ( types , array_5 ) { std :: string code = R \" ( let a = entity(pose(point(1,2,3),quaternion(0,0,0,1)), [\"bouy\"], [point(0,1,2), point(2,3,4), point(3,2,3)]); let b = entity(pose(point(1,2,3),quaternion(0,0,0,1)), [\"bouy\"], [point(0,1,2), point(2,3,4), point(3,2,3)]); let c = [a,b]; ) \" ; polaris :: Parser parser ; ASSERT_TRUE ( parser . evaluate ( code )); const auto c = parser . getValue < std :: vector < polaris :: types :: Entity >> ( \"c\" ); ASSERT_TRUE ( c ); ASSERT_EQ ( c . get (). size (), static_cast < size_t > ( 2 )); const auto a = parser . getValue < polaris :: types :: Entity > ( \"a\" ); ASSERT_TRUE ( a ); ASSERT_DOUBLE_EQ ( a . get (). pose . position . x , 1 ); ASSERT_DOUBLE_EQ ( a . get (). pose . position . y , 2 ); ASSERT_DOUBLE_EQ ( a . get (). pose . position . z , 3 ); ASSERT_EQ ( a . get (). type . size (), static_cast < size_t > ( 1 )); ASSERT_STREQ ( a . get (). type [ 0 ]. c_str (), \"bouy\" ); ASSERT_EQ ( a . get (). polygon . size (), static_cast < size_t > ( 3 )); ASSERT_DOUBLE_EQ ( a . get (). polygon [ 0 ]. x , 0 ); ASSERT_DOUBLE_EQ ( a . get (). polygon [ 0 ]. y , 1 ); ASSERT_DOUBLE_EQ ( a . get (). polygon [ 0 ]. z , 2 ); ASSERT_DOUBLE_EQ ( a . get (). polygon [ 1 ]. x , 2 ); ASSERT_DOUBLE_EQ ( a . get (). polygon [ 1 ]. y , 3 ); ASSERT_DOUBLE_EQ ( a . get (). polygon [ 1 ]. z , 4 ); ASSERT_DOUBLE_EQ ( a . get (). polygon [ 2 ]. x , 3 ); ASSERT_DOUBLE_EQ ( a . get (). polygon [ 2 ]. y , 2 ); ASSERT_DOUBLE_EQ ( a . get (). polygon [ 2 ]. z , 3 ); } TEST ( types , array_6 ) { std :: string code = R \" ( let a=[true, false]; ) \" ; polaris :: Parser parser ; ASSERT_TRUE ( parser . evaluate ( code )); const auto a = parser . getValue < std :: vector < bool >> ( \"a\" ); ASSERT_TRUE ( a ); ASSERT_EQ ( a . get (). size (), static_cast < size_t > ( 2 )); ASSERT_EQ ( a . get ()[ 0 ], true ); ASSERT_EQ ( a . get ()[ 1 ], false ); } int main ( int argc , char ** argv ) { testing :: InitGoogleTest ( & argc , argv ); return RUN_ALL_TESTS (); } Updated on 26 December 2020 at 00:59:10 UTC","title":"Source code"},{"location":"doxygen/markdown/Files/type__base_8hpp/","text":"/home/runner/work/polaris/polaris/include/polaris/types/type_base.hpp # Namespaces # Name polaris::types polaris Classes # Name class polaris::types::TypeBase Source code # // Copyright (c) 2020, OUXT-Polaris // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef POLARIS__TYPES__TYPE_BASE_HPP_ #define POLARIS__TYPES__TYPE_BASE_HPP_ #include <string> #include <type_traits> #include <iostream> namespace polaris { namespace types { template < typename T > class TypeBase { public : TypeBase () {} explicit TypeBase ( const T & v ) : value ( v ) {} T getValue () const { return value ;} void setValue ( const T & v ) { value = v ;} bool matchValueType ( const std :: type_info & type ) const { if ( typeid ( T ) == type ) { return true ; } return false ; } private : T value ; }; } // namespace types } // namespace polaris #endif // POLARIS__TYPES__TYPE_BASE_HPP_ Updated on 26 December 2020 at 00:59:10 UTC","title":"/home/runner/work/polaris/polaris/include/polaris/types/type_base.hpp"},{"location":"doxygen/markdown/Files/type__base_8hpp/#homerunnerworkpolarispolarisincludepolaristypestype_basehpp","text":"","title":"/home/runner/work/polaris/polaris/include/polaris/types/type_base.hpp"},{"location":"doxygen/markdown/Files/type__base_8hpp/#namespaces","text":"Name polaris::types polaris","title":"Namespaces"},{"location":"doxygen/markdown/Files/type__base_8hpp/#classes","text":"Name class polaris::types::TypeBase","title":"Classes"},{"location":"doxygen/markdown/Files/type__base_8hpp/#source-code","text":"// Copyright (c) 2020, OUXT-Polaris // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef POLARIS__TYPES__TYPE_BASE_HPP_ #define POLARIS__TYPES__TYPE_BASE_HPP_ #include <string> #include <type_traits> #include <iostream> namespace polaris { namespace types { template < typename T > class TypeBase { public : TypeBase () {} explicit TypeBase ( const T & v ) : value ( v ) {} T getValue () const { return value ;} void setValue ( const T & v ) { value = v ;} bool matchValueType ( const std :: type_info & type ) const { if ( typeid ( T ) == type ) { return true ; } return false ; } private : T value ; }; } // namespace types } // namespace polaris #endif // POLARIS__TYPES__TYPE_BASE_HPP_ Updated on 26 December 2020 at 00:59:10 UTC","title":"Source code"},{"location":"doxygen/markdown/Modules/","text":"Modules # Updated on 26 December 2020 at 00:59:10 UTC","title":"Modules"},{"location":"doxygen/markdown/Modules/#modules","text":"Updated on 26 December 2020 at 00:59:10 UTC","title":"Modules"},{"location":"doxygen/markdown/Namespaces/","text":"Namespaces # namespace polaris namespace built_in_functions namespace types Updated on 26 December 2020 at 00:59:10 UTC","title":"Namespaces"},{"location":"doxygen/markdown/Namespaces/#namespaces","text":"namespace polaris namespace built_in_functions namespace types Updated on 26 December 2020 at 00:59:10 UTC","title":"Namespaces"},{"location":"doxygen/markdown/Namespaces/namespacepolaris/","text":"polaris # Namespaces # Name polaris::types polaris::built_in_functions Classes # Name class polaris::Parser class polaris::EvaluationError Updated on 26 December 2020 at 00:59:10 UTC","title":"polaris"},{"location":"doxygen/markdown/Namespaces/namespacepolaris/#polaris","text":"","title":"polaris"},{"location":"doxygen/markdown/Namespaces/namespacepolaris/#namespaces","text":"Name polaris::types polaris::built_in_functions","title":"Namespaces"},{"location":"doxygen/markdown/Namespaces/namespacepolaris/#classes","text":"Name class polaris::Parser class polaris::EvaluationError Updated on 26 December 2020 at 00:59:10 UTC","title":"Classes"},{"location":"doxygen/markdown/Namespaces/namespacepolaris_1_1built__in__functions/","text":"polaris::built_in_functions # Classes # Name class polaris::built_in_functions::Functions Updated on 26 December 2020 at 00:59:10 UTC","title":"polaris::built_in_functions"},{"location":"doxygen/markdown/Namespaces/namespacepolaris_1_1built__in__functions/#polarisbuilt_in_functions","text":"","title":"polaris::built_in_functions"},{"location":"doxygen/markdown/Namespaces/namespacepolaris_1_1built__in__functions/#classes","text":"Name class polaris::built_in_functions::Functions Updated on 26 December 2020 at 00:59:10 UTC","title":"Classes"},{"location":"doxygen/markdown/Namespaces/namespacepolaris_1_1types/","text":"polaris::types # Classes # Name class polaris::types::TypeBase class polaris::types::Entity Updated on 26 December 2020 at 00:59:10 UTC","title":"polaris::types"},{"location":"doxygen/markdown/Namespaces/namespacepolaris_1_1types/#polaristypes","text":"","title":"polaris::types"},{"location":"doxygen/markdown/Namespaces/namespacepolaris_1_1types/#classes","text":"Name class polaris::types::TypeBase class polaris::types::Entity Updated on 26 December 2020 at 00:59:10 UTC","title":"Classes"},{"location":"doxygen/markdown/Pages/","text":"Pages # Updated on 26 December 2020 at 00:59:10 UTC","title":"Pages"},{"location":"doxygen/markdown/Pages/#pages","text":"Updated on 26 December 2020 at 00:59:10 UTC","title":"Pages"}]}